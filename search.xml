<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【F1 2021】西班牙计时圈（持续更新）</title>
      <link href="/2021/07/23/spain-tt-1-16-5/"/>
      <url>/2021/07/23/spain-tt-1-16-5/</url>
      
        <content type="html"><![CDATA[<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=546797789&bvid=BV1Sq4y1W71p&cid=374722002&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 模拟赛车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> F1 2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer 20. 表示数值的字符串</title>
      <link href="/2021/07/23/finite-state-machine/"/>
      <url>/2021/07/23/finite-state-machine/</url>
      
        <content type="html"><![CDATA[<p>最清晰的方法是有限元自动机，继续盗一下<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/">K大</a>的图。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/45FNAd.jpg" alt="45FNAd"></p><p>然后用dict / hashmap把状态转移用键值对表达出来即可。字符串读入成字符数组，遍历字符元素匹配空格、正负号、数字、e以及小数点进行状态转移，如果不存在则直接返回false。遍历结束后如果停留在：空格、（连续或前面为小数点或空格或e的）数字、前面有数字的小数点，则符合规则返回true。</p><p>（我自己脑补的状态序列，所以序号和图上有一点出入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map[] states = &#123;</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123;put(<span class="string">&#x27; &#x27;</span>, <span class="number">0</span>); put(<span class="string">&#x27;s&#x27;</span>, <span class="number">1</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">6</span>); put(<span class="string">&#x27;s&#x27;</span>, <span class="number">7</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">6</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">6</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123;put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>);&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> token;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) token = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>) token = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;.&#x27;</span> || ch == <span class="string">&#x27; &#x27;</span>) token = ch;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;e&#x27;</span> || ch == <span class="string">&#x27;E&#x27;</span>) token = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> token = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!states[state].containsKey(token)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            state = (<span class="keyword">int</span>)states[state].get(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (state == <span class="number">2</span> || state == <span class="number">4</span> || state == <span class="number">6</span> || state == <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> medium difficulty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂和快速幂求余</title>
      <link href="/2021/07/22/quick-pow-mod/"/>
      <url>/2021/07/22/quick-pow-mod/</url>
      
        <content type="html"><![CDATA[<p>题目：</p><ul><li><p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方 - 力扣（LeetCode） (leetcode-cn.com)</a></p></li><li><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II - 力扣（LeetCode） (leetcode-cn.com)</a></p></li></ul><h2 id="快速幂">快速幂</h2><p>例子： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>11</mn></msup></mrow><annotation encoding="application/x-tex">x^{11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span></span></span></span></span></span></span></span></p><p>原理：</p><ol><li>将要求的幂的指数转为二进制形式，如11转换为1011。因此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>11</mn></msup><mo>=</mo><msup><mi>x</mi><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><msup><mn>2</mn><mn>0</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">x^{11}=x^{2^{3}+2^{1}+2^{0}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9869199999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li>由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><msup><mn>2</mn><mn>0</mn></msup></mrow></msup><mo>=</mo><msup><mi>x</mi><msup><mn>2</mn><mn>3</mn></msup></msup><mo>×</mo><msup><mi>x</mi><msup><mn>2</mn><mn>1</mn></msup></msup><mo>×</mo><msup><mi>x</mi><msup><mn>2</mn><mn>0</mn></msup></msup></mrow><annotation encoding="application/x-tex">x^{2^{3}+2^{1}+2^{0}}=x^{2^{3}} \times x^{2^{1}} \times x^{2^{0}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869199999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.07025em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.07025em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9869199999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，也就是只需要将每一位1所对应的权重相乘</li><li>实现方法就是首先初始化<code>long b = n</code>和<code>double res = 1.0</code>，使用按位与1运算判断最小位是否为1。如果为1，则<code>res</code>乘上此时的底数<code>x</code>。操作完成后<code>b</code>需要右移一位。</li><li>在进入下一次循环之前，需要让底数的指数翻倍<code>x *= x</code>，以匹配右移后的<code>b</code>。</li></ol><p>剑16代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> b = n;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                res *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂求余">快速幂求余</h2><p>剑14-II：这道题虽然可以直接用上述的快速幂封装方法代替<code>Math.pow()</code>或者<code>a ** b</code>，但是<a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/">K神用的方法</a>看起来更牛逼，还是学习一下。</p><p>如果直接使用封装的快速幂方法，则需要修改如下。依据是求余的性质</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo><mo>⊙</mo><mi>p</mi><mo>=</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⊙</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo>⊙</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>⊙</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">(x y) \odot p=[(x \odot p)(y \odot p)] \odot p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose">)]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">myPow</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">      res *= x;</span><br><span class="line">      res = res % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    x *= x;</span><br><span class="line">    x = x % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把剑14-I的解法套过来就好～</p>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> medium difficulty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 343. 整数拆分 / 剑指offer14-I 剪绳子</title>
      <link href="/2021/07/21/integer-break/"/>
      <url>/2021/07/21/integer-break/</url>
      
        <content type="html"><![CDATA[<p>柯西不等式 假设都相等的时候乘积最大 最后会转化成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>x</mi><mfrac><mn>1</mn><mi>x</mi></mfrac></msup></mrow><annotation encoding="application/x-tex">y = x^{\frac{1}{x}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9540200000000001em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9540200000000001em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>求极大值 直接用wolfram求求</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/USDkXj.png" alt="USDkXj"></p><p>用2和3试一下 发现3的结果更大</p><p>2只能分成1x1</p><p>3只能分成1x1x1或者1x2 后者大</p><p>商为a 余数为b 做如下分类讨论</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a-<span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> medium difficulty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的层序遍历</title>
      <link href="/2021/07/20/binary-tree-bfs/"/>
      <url>/2021/07/20/binary-tree-bfs/</url>
      
        <content type="html"><![CDATA[<p>基本上是围绕着这两题：<a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化 - 力扣（LeetCode） (leetcode-cn.com)</a>和<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>补充：加入<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指offer32-II 力扣 (leetcode-cn.com)</a></p><p>Leetcode 297:</p><ol><li>序列化部分，需要充分理解队列的使用。</li></ol><ul><li>队列用于存储下一层广度优先遍历的节点。</li><li>当从队列中取出一个非空节点时，需要同时将该节点的左右子节点放入队列末尾。</li><li>从队列中依次取出节点并放在返回的序列（字符串）尾端。</li><li>如果当前取出节点为空，则字符串加入“null”以表示空节点。</li></ul><p>需要的数据结构：StringBuilder构造字符串，队列存储下一步需要遍历的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">  StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  res.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">  Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  q.add(root);</span><br><span class="line">  <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">    TreeNode cur = q.poll();</span><br><span class="line">    <span class="keyword">if</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">      res.append(cur.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">      q.add(cur.left);</span><br><span class="line">      q.add(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> res.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">  res.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>反序列化部分，首先取括号内的部分分割一下得到字符串数组</li></ol><ul><li>队列用来存储需要遍历的节点。和上面一样，队列为空时遍历结束。</li><li>先把根节点放入队列，从<code>i=1</code>位置开始遍历字符串数组（根节点的左子节点）。</li><li>如果第<code>i</code>项不为<code>null</code>，则字符串数组的第<code>i</code>项作为左子树；<code>i</code>自增后相同规则处理右子树</li><li><code>i</code>再自增一次。两次自增与第<code>i</code>项是否为空无关，因此写在条件之外。</li><li>左右子树要加入队列以进行下一步遍历。BFS结束后返回根节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(data.equals(<span class="string">&quot;[]&quot;</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  String[] strs = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[<span class="number">0</span>]));</span><br><span class="line">  q.add(root);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">    TreeNode cur = q.poll();</span><br><span class="line">    <span class="keyword">if</span>(!strs[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">      cur.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[i]));</span><br><span class="line">      q.add(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">    ++i;</span><br><span class="line">    <span class="keyword">if</span>(!strs[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">      cur.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[i]));</span><br><span class="line">      q.add(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剑指offer32-I：</p><p>和上面那题的序列化部分规则差不多，返回结果用数组存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;&#125;;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) q.add(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) q.add(cur.right);</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">            ans[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剑指offer32-II：</p><p>需要按层输出，所以需要使用for循环来设定当前层的循环次数，循环结束后在<code>List&lt;List&gt;</code>中<code>add</code>一个<code>List</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">          List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">              tmp.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) q.add(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) q.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">          res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 82.删除排序链表中的重复元素 II</title>
      <link href="/2021/07/16/leetcode-82/"/>
      <url>/2021/07/16/leetcode-82/</url>
      
        <content type="html"><![CDATA[<p>最基本的链表题目，需要注意的问题就是最后别忘了<code>tail.next = null</code>这样一回事…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode tail = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode dummy = tail;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.next == <span class="keyword">null</span> || head.val != head.next.val) &#123;</span><br><span class="line">                tail.next = head;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(head.next != <span class="keyword">null</span> &amp;&amp; head.val == head.next.val) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> medium difficulty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 74. 搜索二维矩阵</title>
      <link href="/2021/07/15/leetcode-74/"/>
      <url>/2021/07/15/leetcode-74/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">https://leetcode-cn.com/problems/search-a-2d-matrix/</a></p><p>题目比较简单，一上来的想法是二分，因为从题干可以看出这个矩阵其实可以看作一位数组处理。需要转换的逻辑只有<code>mid</code>的含义。由于题目输入是二维矩阵，此时的<code>mid</code>代表的其实是假设<code>flatten</code>到一维后的<code>index</code>，所以要转换成二维坐标<code>(mid/n, mid%n)</code>处理。</p><p>继续注意二分的各种边界问题～</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + right + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid / n][mid % n] &lt;= target) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (matrix[left / n][left % n] == target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> medium difficulty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【F1 2020】澳大利亚计时圈（持续更新）</title>
      <link href="/2021/07/15/australia-tt-1-20-7/"/>
      <url>/2021/07/15/australia-tt-1-20-7/</url>
      
        <content type="html"><![CDATA[<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=759141789&bvid=BV1v64y1X7jp&cid=368897752&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 模拟赛车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> F1 2020 </tag>
            
            <tag> Melbourne Gran Prix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1846. 减小和重新排列数组后的最大元素</title>
      <link href="/2021/07/15/leetcode-1846/"/>
      <url>/2021/07/15/leetcode-1846/</url>
      
        <content type="html"><![CDATA[<p>原题链接：<a href="https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging/">https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging/</a></p><p><em>给你一个正整数数组 <code>arr</code> 。请你对 <code>arr</code> 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：</em></p><p><em><code>arr</code> 中 第一个 元素必须为 1 。</em><br><em>任意相邻两个元素的差的绝对值 小于等于 <code>1</code> ，也就是说，对于任意的 <code>1 &lt;= i &lt; arr.length</code> （数组下标从 <code>0</code> 开始），都满足 <code>abs(arr[i] - arr[i - 1]) &lt;= 1</code> 。<code>abs(x)</code> 为 <code>x</code> 的绝对值。</em><br><em>你可以执行以下 2 种操作任意次：</em></p><p><em>减小 <code>arr</code> 中任意元素的值，使其变为一个 更小的正整数 。</em><br><em>重新排列 <code>arr</code> 中的元素，你可以以任意顺序重新排列。</em><br><em>请你返回执行以上操作后，在满足前文所述的条件下，<code>arr</code> 中可能的 最大值 。</em></p><p>易证满足上述条件的数组要满足非严格单调递增分布（脑补一下），排序数组后强制使第一位为1，后续元素如果与前一位差值超过题目要求就设为前一位+1。不知道这样说有没有毛病。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumElementAfterDecrementingAndRearranging</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(arr[i] - arr[i-<span class="number">1</span>]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                arr[i] = arr[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> medium difficulty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 981. 基于时间的键值存储</title>
      <link href="/2021/07/11/leetcode-981/"/>
      <url>/2021/07/11/leetcode-981/</url>
      
        <content type="html"><![CDATA[<h5 id="981-基于时间的键值存储"><a href="https://leetcode-cn.com/problems/time-based-key-value-store/">981. 基于时间的键值存储</a></h5><p><a href="https://leetcode-cn.com/problems/time-based-key-value-store/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-h5et/">题解：宫水三叶</a></p><p>先做HashMap+数组的基本解法和偷鸡解法。后面再看HashMap+树的做法。这里需要注意看题目，题目表明：</p><p>​所有 <code>TimeMap.set</code> 操作中的时间戳 <code>timestamps</code> 都是严格递增的。</p><p>因此可以利用二分查找达成“找到小于等于查询时间戳的最大时间戳的键值”这一要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        String k, v;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        Node(String k, String v, <span class="keyword">int</span> t) &#123;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">            <span class="keyword">this</span>.t = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, List&lt;Node&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        List&lt;Node&gt; list = map.getOrDefault(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        list.add(<span class="keyword">new</span> Node(key, value, timestamp));</span><br><span class="line">        map.put(key,list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        List&lt;Node&gt; list = map.getOrDefault(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = list.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(list.get(mid).t &lt;= timestamp) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(r).t &lt;= timestamp ? list.get(r).v : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>偷鸡做法：<code>floorEntry</code> （从<a href="https://leetcode-cn.com/u/trager324-m/">大佬那里</a>抄来学习一下）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span> </span>&#123;</span><br><span class="line">    Map&lt;String, TreeMap&lt;Integer, String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        map.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> TreeMap&lt;&gt;()).put(timestamp, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        Map.Entry&lt;Integer, String&gt; entry = map.getOrDefault(key, <span class="keyword">new</span> TreeMap&lt;&gt;()).floorEntry(timestamp);</span><br><span class="line">        <span class="keyword">return</span> entry == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> medium difficulty </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 39. 组合总和</title>
      <link href="/2021/07/10/leetcode-39-combination-sum/"/>
      <url>/2021/07/10/leetcode-39-combination-sum/</url>
      
        <content type="html"><![CDATA[<p>题目链接 <a href="https://leetcode-cn.com/problems/combination-sum/">https://leetcode-cn.com/problems/combination-sum/</a></p><p>深度优先搜索、回溯、剪枝。</p><p>参照[liweiliwei1419的题解](<a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">回溯算法 + 剪枝（回溯经典例题详解） - 组合总和 - 力扣（LeetCode） (leetcode-cn.com)</a>)，如果<code>candidates = [2,3,6,7], target = 7</code>，先画出类似如下的树形图，边上的数值为<code>candidates</code>的元素，从根到所有为<code>0</code>的节点的路径就是合法路径。深度优先搜索到节点为<code>0</code>或者为负数时停止该分支上的搜索（后续可以排序<code>candidates</code>进行剪枝）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic.leetcode-cn.com/1598091943-hZjibJ-file_1598091940241" alt="img"></p><p>存储搜索路径的数据结构使用双向队列，在递归完成对当前节点的深度优先搜索后需要removeLast来reset路径状态回到搜索之前。</p><p>在搜索某一节点时，每一个分支的搜索起始点需要在candidates中向后移动一个位置，以避免使用同一层已经使用过的元素导致结果出现重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = candidates.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(res, candidates, target, <span class="number">0</span>, path, len);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> begin,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Deque&lt;Integer&gt; path, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; len; i++) &#123;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(res, candidates, target - candidates[i], i, path, len);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剪枝：排序数组，当下一节点已经为负数时，这个节点就不再往下搜索了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = candidates.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(res, candidates, target, <span class="number">0</span>, path, len);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> begin,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Deque&lt;Integer&gt; path, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target - candidates[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(res, candidates, target - candidates[i], i, path, len);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> medium difficulty </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 31. 下一个排列</title>
      <link href="/2021/07/09/Leetcode-31-next-permutation/"/>
      <url>/2021/07/09/Leetcode-31-next-permutation/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>看看这个链接！评论区有人API一把梭…不行 我用的是Java</p><p>理解题解：两轮从尾部开始的扫描，第一轮找出第一个顺序对<code>nums[i], nums[i+1]</code>，以此为分界，之后为倒序。第二轮找出后面倒序的部分里从后往前第一个大于<code>nums[i]</code>的元素<code>nums[j]</code>，和<code>nums[i]</code>交换。此时后面还是倒序（因为<code>nums[j]&gt;nums[i]</code>，<code>nums[j+1]&lt;nums[i]</code>， <code>nums[j-1]&gt;nums[j]</code>），所以只要用双指针往中央扫描、前后交换的方式排一下序就好了。一共涉及三次扫描操作，复杂度<code>O(N)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            --i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= i+<span class="number">1</span> &amp;&amp; nums[j] &lt;= nums[i]) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// easy</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = begin, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> medium difficulty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP佛脚笔记</title>
      <link href="/2021/01/23/NLP-cheatsheet-notes/"/>
      <url>/2021/01/23/NLP-cheatsheet-notes/</url>
      
        <content type="html"><![CDATA[<p>（施工中……）</p><p>复制粘贴为主 比较简单只是为了定性地熟悉和回忆一下相关知识 但是如果有大佬发现了低级错误 请不吝在评论区中及时指出 授人玫瑰🌹手留余香 感恩❤️</p><p>主要参考资料：<a href="https://github.com/NLP-LOVE/ML-NLP">https://github.com/NLP-LOVE/ML-NLP</a></p><h1>Machine Learning / Deep Learning部分</h1><h2 id="基本概念">基本概念</h2><h3 id="激活函数：sigmoid，Tanh，ReLU，Leaky-ReLU，PReLU，ELU，Maxout"><a href="https://zhuanlan.zhihu.com/p/71882757">激活函数：sigmoid，Tanh，ReLU，Leaky ReLU，PReLU，ELU，Maxout</a></h3><h4 id="sigmoid">sigmoid</h4><p>sigmoid函数又称 Logistic函数，用于隐层神经元输出，取值范围为(0,1)，可以用来做二分类。</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Csigma%28x%29%3D%5Cfrac%7B1%7D%7B1%2Be%5E%7B-x%7D%7D" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/avTdiw.jpg" alt="avTdiw"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/JOADpO.jpg" alt="JOADpO"></p><p>优点：</p><ul><li><p>Sigmoid函数的输出在(0,1)之间，输出范围有限，优化稳定，可以用作输出层。</p></li><li><p>连续函数，便于求导。</p></li></ul><p>缺点：</p><ul><li><p>sigmoid函数在变量取绝对值非常大的正值或负值时会出现饱和现象，意味着函数会变得很平，并且对输入的微小改变会变得不敏感。</p></li><li><p>在反向传播时，当梯度接近于0，权重基本不会更新，很容易就会出现梯度消失的情况，从而无法完成深层网络的训练。</p></li><li><p>sigmoid函数的输出不是0均值的，会导致后层的神经元的输入是非0均值的信号，这会对梯度产生影响。</p></li><li><p>计算复杂度高，因为sigmoid函数是指数形式。</p></li></ul><h4 id="Tanh">Tanh</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/PbkLCR.jpg" alt="PbkLCR"></p><h4 id="ReLU">ReLU</h4><p><strong>整流线性单元</strong>（Rectified linear unit，ReLU）是现代神经网络中最常用的激活函数，大多数前馈神经网络默认使用的激活函数。</p><p>ReLU函数定义如下： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=f%28x%29%3Dmax%280%2Cx%29" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/jLl62p.jpg" alt="jLl62p"></p><p><strong>优点：</strong></p><p>使用ReLU的SGD算法的收敛速度比 sigmoid 和 tanh 快。</p><p>在x&gt;0区域上，不会出现梯度饱和、梯度消失的问题。</p><p>计算复杂度低，不需要进行指数运算，只要一个阈值就可以得到激活值。</p><p><strong>缺点：</strong></p><p>ReLU的输出<strong>不是0均值</strong>的。</p><p><strong>Dead ReLU Problem(神经元坏死现象)</strong>：ReLU在负数区域被kill的现象叫做dead relu。ReLU在训练的时很“脆弱”。在x&lt;0时，梯度为0。这个神经元及之后的神经元梯度永远为0，不再对任何数据有所响应，导致相应参数永远不会被更新。</p><p><strong>产生</strong>这种现象的两个<strong>原因</strong>：参数初始化问题；learning rate太高导致在训练过程中参数更新太大。</p><p><strong>解决方法</strong>：采用Xavier初始化方法，以及避免将learning rate设置太大或使用adagrad等自动调节learning rate的算法。</p><h4 id="LeakyReLU">LeakyReLU</h4><p><strong>渗漏整流线性单元</strong>(Leaky ReLU)，为了解决dead ReLU现象。用一个类似0.01的小值来初始化神经元，从而<strong>使得ReLU在负数区域更偏向于激活而不是死掉</strong>。这里的斜率都是确定的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/nIEhNp.jpg" alt="nIEhNp"></p><h3 id="损失函数">损失函数</h3><h4 id="交叉熵cross-entropy">交叉熵cross-entropy</h4><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=L+%3D+%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%7D+L_i+%3D+%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%7D-%5By_i%5Ccdot+log%28p_i%29+%2B+%281-y_i%29%5Ccdot+log%281-p_i%29%5D+%5C%5C" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=L+%3D+%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%7D+L_i+%3D+%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%7D+-%5Csum_%7Bc%3D1%7D%5EMy_%7Bic%7D%5Clog%28p_%7Bic%7D%29+%5C%5C" alt="[公式]"></p><p>当使用sigmoid作为激活函数的时候，常用<strong>交叉熵损失函数</strong>而不用<strong>均方误差损失函数</strong>，因为它可以<strong>完美解决平方损失函数权重更新过慢</strong>的问题，具有“误差大的时候，权重更新快；误差小的时候，权重更新慢”的良好性质。</p><h2 id="模型八股">模型八股</h2><h3 id="RNN">RNN</h3><p>结构：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/Itl4lS.jpg" alt="Itl4lS"></p><p>缺点：Gradient Vanishing, No Long-distance dependency</p><h3 id="LSTM">LSTM</h3><p>结构：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/bSUX3M.jpg" alt="bSUX3M"></p><p>其中，f代表forget，对上一状态的c(t-1)进行选择性遗忘，i代表对x(t)输入后的候选记忆细胞c’(t)进行选择性记忆。这两个结果相加再经过一层o（决定哪些会被输出）构成了真正的当前状态c(t)的隐藏状态h(t)。</p><p><strong>记忆门：</strong><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/QpE9hp.jpg" alt="QpE9hp"></p><p><strong>遗忘门：</strong><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/3SIJu6.jpg" alt="3SIJu6"></p><p><strong>输出门：</strong><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/tYsOzX.jpg" alt="tYsOzX"></p><p><strong>候选记忆细胞：</strong><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/VYjN0N.jpg" alt="VYjN0N"></p><p><strong>记忆细胞</strong>：<img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/qhhBRW.jpg" alt="qhhBRW"></p><p><strong>隐藏状态：</strong><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/Ep0OYF.jpg" alt="Ep0OYF"></p><p>优缺点：with long-distance dependency, but more difficult to train(more parameters)</p><h1>NLP部分</h1><h2 id="基本概念-2">基本概念</h2><h3 id="Word-Embedding">Word Embedding</h3><p>Use vectors to represent words 把词映射为实数域向量的技术</p><h4 id="Methods">Methods</h4><h5 id="One-Hot">One-Hot</h5><p>Pros: Expand the dimension of features</p><p>Cons: 随着语料库的增加，数据特征的维度会越来越大，产生一个维度很高，又很稀疏的矩阵。这种表示方法的分词顺序和在句子中的顺序是无关的，不能保留词与词之间的关系信息。</p><h5 id="Bag-of-Words">Bag of Words</h5><p>Cons: 词出现的越多特征越明显，但不代表这个词重要/权重应该更大。词与词之间的顺序关系被抹除。</p><h5 id="TF-IDF">TF-IDF</h5><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/rpP7Sr.jpg" alt="rpP7Sr"></p><p>含义：某个term在一篇文章中出现的频率越高 &amp; 这个term在所有文档中出现的次数越少，越能够代表这个文章。TFIDF方法主要是对词向量进行加权。</p><h5 id="n-gram">n-gram</h5><p>Cons：随着n的大小增大，词表会呈现指数型膨胀。</p><h2 id="模型八股-2">模型八股</h2><h4 id="Word2Vec"><a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/NLP/16.1%20Word%20Embedding#42-word2vec">Word2Vec</a></h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/0LXo0u.jpg" alt="0LXo0u"></p><p>本质：训练上下文预测的神经网络模型，利用隐藏层权重矩阵作为向量化表示。所需要的结果是输入层和隐藏层之间的权重矩阵W，用输入乘以W就是词向量表示。</p><p>方式：CBOW（连续词袋，预测下文）or Skip-gram（根据上下文预测词语）</p><h4 id="Attention">Attention</h4><p>结构：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/ReyEHg.jpg" alt="ReyEHg"></p><p>利用i-1的隐藏层输出计算概率分布，softmax归一化</p><h4 id="Transformer">Transformer</h4><p>结构：Transformer的结构和Attention模型一样，Transformer模型中也采用了 encoer-decoder 架构。但其结构相比于Attention更加复杂，论文中encoder层由6个encoder堆叠在一起，decoder层也一样。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/XR389N.jpg" alt="XR389N"></p><ul><li>encoder，包含两层，一个self-attention层和一个前馈神经网络，self-attention能帮助当前节点不仅仅只关注当前的词，从而能获取到上下文的语义。</li><li>decoder也包含encoder提到的两层网络，但是在这两层中间还有一层attention层，帮助当前节点获取到当前需要关注的重点内容。</li></ul><h4 id="ELMo-Embedding-from-Language-Models">ELMo (Embedding from Language Models)</h4><p>For what : Word Embedding 无法解决同义词（Synonym）问题</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/D6H9k9.jpg" alt="D6H9k9"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/WcecY6.png" alt="WcecY6"></p><h4 id="BERT：A-Pre-training-model">BERT：A Pre-training model</h4><p>结构</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/P2stYh.jpg" alt="P2stYh"></p><p>BERT预训练模型分为以下三个步骤：<strong>Embedding、Masked LM、Next Sentence Prediction</strong></p><ul><li><p>Embedding：这里的Embedding由三种Embedding求和而成</p><ul><li>Token Embeddings是词向量，第一个单词是CLS标志，可以用于之后的分类任务</li><li>Segment Embeddings用来区别两种句子，因为预训练不光做LM还要做以两个句子为输入的分类任务</li><li>Position Embeddings和之前文章中的Transformer不一样，不是三角函数而是学习出来的</li></ul></li><li><p>MLM可以理解为完形填空，作者会随机mask每一个句子中15%的词，用其上下文来做预测，例如：my dog is hairy → my dog is [MASK]</p><p>此处将hairy进行了mask处理，然后采用非监督学习的方法预测mask位置的词是什么，但是该方法有一个问题，因为是mask15%的词，其数量已经很高了，这样就会导致某些词在fine-tuning阶段从未见过，为了解决这个问题，作者做了如下的处理：</p><p>80%是采用[mask]，my dog is hairy → my dog is [MASK]</p><p>10%是随机取一个词来代替mask的词，my dog is hairy -&gt; my dog is apple</p><p>10%保持不变，my dog is hairy -&gt; my dog is hairy</p></li><li><p>选择一些句子对A与B，其中50%的数据B是A的下一条句子，剩余50%的数据B是语料库中随机选择的，学习其中的相关性，添加这样的预训练的目的是目前很多NLP的任务比如QA和NLI都需要理解两个句子之间的关系，从而能让预训练的模型更好的适应这样的任务。 个人理解：</p><ul><li>Bert先是用Mask来提高视野范围的信息获取量，增加duplicate再随机Mask，这样跟RNN类方法依次训练预测没什么区别了除了mask不同位置外；</li><li>全局视野极大地降低了学习的难度，然后再用A+B/C来作为样本，这样每条样本都有50%的概率看到一半左右的噪声；</li><li>但直接学习Mask A+B/C是没法学习的，因为不知道哪些是噪声，所以又加上next_sentence预测任务，与MLM同时进行训练，这样用next来辅助模型对噪声/非噪声的辨识，用MLM来完成语义的大部分的学习。</li></ul></li></ul><h4 id="GPT-GPT-2">GPT / GPT-2</h4><h4 id="XLNET">XLNET</h4><h5 id="自回归vs自编码">自回归vs自编码</h5><ul><li><p><strong>Autoregressive LM:</strong> 在ELMO／BERT出来之前，大家通常讲的语言模型其实是根据上文内容预测下一个可能跟随的单词，就是常说的自左向右的语言模型任务，或者反过来也行，就是根据下文预测前面的单词，这种类型的LM被称为自回归语言模型。GPT 就是典型的自回归语言模型。ELMO尽管看上去利用了上文，也利用了下文，但是本质上仍然是自回归LM，这个跟模型具体怎么实现有关系。ELMO是做了两个方向（从左到右以及从右到左两个方向的语言模型），但是是分别有两个方向的自回归LM，然后把LSTM的两个方向的隐节点状态拼接到一起，来体现双向语言模型这个事情的。所以其实是两个自回归语言模型的拼接，本质上仍然是自回归语言模型。</p><p>自回归语言模型有优点有缺点：</p><p><strong>缺点</strong>是只能利用上文或者下文的信息，不能同时利用上文和下文的信息，当然，貌似ELMO这种双向都做，然后拼接看上去能够解决这个问题，因为融合模式过于简单，所以效果其实并不是太好。</p><p><strong>优点</strong>其实跟下游NLP任务有关，比如生成类NLP任务，比如文本摘要，机器翻译等，在实际生成内容的时候，就是从左向右的，自回归语言模型天然匹配这个过程。而Bert这种DAE模式，在生成类NLP任务中，就面临训练过程和应用过程不一致的问题，导致生成类的NLP任务到目前为止都做不太好。</p></li><li><p><strong>Autoencoder:</strong> 自回归语言模型只能根据上文预测下一个单词，或者反过来，只能根据下文预测前面一个单词。相比而言，Bert通过在输入X中随机Mask掉一部分单词，然后预训练过程的主要任务之一是根据上下文单词来预测这些被Mask掉的单词，如果你对Denoising Autoencoder比较熟悉的话，会看出，这确实是典型的DAE的思路。那些被Mask掉的单词就是在输入侧加入的所谓噪音。类似Bert这种预训练模式，被称为DAE LM。</p><p>这种DAE LM的优缺点正好和自回归LM反过来，它能比较自然地融入双向语言模型，同时看到被预测单词的上文和下文，这是好处。<strong>缺点</strong>是啥呢？主要在输入侧引入[Mask]标记，导致预训练阶段和Fine-tuning阶段不一致的问题，因为Fine-tuning阶段是看不到[Mask]标记的。DAE吗，就要引入噪音，[Mask] 标记就是引入噪音的手段，这个正常。</p><p>XLNet的出发点就是：能否融合自回归LM和DAE LM两者的优点。就是说如果站在自回归LM的角度，如何引入和双向语言模型等价的效果；如果站在DAE LM的角度看，它本身是融入双向语言模型的，如何抛掉表面的那个[Mask]标记，让预训练和Fine-tuning保持一致。当然，XLNet还讲到了一个Bert被Mask单词之间相互独立的问题。</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/QrjZXO.jpg" alt="QrjZXO"></p><h4 id="GloVe">GloVe</h4><p><em>共现矩阵</em>（Co-occurrence Matrix）</p><h4 id="ULMFit">ULMFit</h4><h3 id="评价指标">评价指标</h3><h4 id="F1">F1</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/c9DWK1.jpg" alt="c9DWK1"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/xO3RyO.jpg" alt="xO3RyO"></p><h4 id="BLeu">BLeu</h4><h5 id="核心思想">核心思想</h5><p>比较候选译文和参考译文里的 n-gram 的重合程度，重合程度越高就认为译文质量越高。unigram用于衡量单词翻译的准确性，高阶n-gram用于衡量句子翻译的流畅性。 实践中，通常是取N=1~4，然后对进行加权平均。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/davekim3872/blogpics@master/uPic/DNyUpN.png" alt="DNyUpN"></p><h5 id="主要特点">主要特点</h5><ul><li>n-gram共现统计</li><li>基于精确率</li></ul><h5 id="应用场景">应用场景</h5><p>Machine Translation</p><h5 id="缺点">缺点</h5><ul><li><p>只看重精确率，不看重召回率。</p></li><li><p>存在常用词干扰（可以用截断的方法解决）</p></li><li><p>短句得分较高。即使引入了brevity penalty，也还是不够。</p></li></ul><h5 id="改进">改进</h5><ul><li>截断：改进常用词干扰</li><li>brevity penalty：改进短句得分较高的问题</li></ul><h4 id="Rouge">Rouge</h4><h5 id="核心思想-2">核心思想</h5><p>大致分为四种：ROUGE-N，ROUGE-L，ROUGE-W，ROUGE-S。常用的是前两种（-N与-L） * ROUGE-N中的“N”指的是N-gram，其计算方式与BLEU类似，只是BLEU基于精确率，而ROUGE基于召回率。</p><ul><li>ROUGE-L中的“L”指的是Longest Common Subsequence，计算的是候选摘要与参考摘要的最长公共子序列长度，长度越长，得分越高，基于F值。</li></ul><p>![image-20210125134654580](/Users/dawei/Library/Application Support/typora-user-images/image-20210125134654580.png)</p>]]></content>
      
      
      <categories>
          
          <category> 面试复习小抄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PySpark调用Scala UDF</title>
      <link href="/2020/08/31/pyspark-use-scala-udf/"/>
      <url>/2020/08/31/pyspark-use-scala-udf/</url>
      
        <content type="html"><![CDATA[<p>在编写PySpark脚本时，有些列运算在spark当中并没有符合需求的方法，需要使用UDF。通过调用jar中的UDF，可以减少python与JVM的交互；用牺牲UDF部分的开发时间，尽量提高性能。本文将简述如何在PySpark脚本中调用Scala编写的UDF（以一个简单的函数为例）。</p><p>关于scala语法、spark&amp;scala的内容可以参考：</p><ul><li><p><a href="http://dblab.xmu.edu.cn/blog/spark/">Spark入门教程Scala版——厦门大学林子雨</a>；</p></li><li><p><a href="https://www.runoob.com/scala/scala-tutorial.html">菜鸟教程——Scala教程</a></p></li></ul><p>本文依赖的开发环境为：Scala==2.11.7 / Spark &amp; PySpark==2.1.2 / JDK 1.8</p><h2 id="1-安装配置Scala">1. 安装配置Scala</h2><p>虽然IDEA里可以下载安装Scala，但是可能因为服务器在国外所以速度比较慢。建议先直接手动安装。</p><p>下载解压Scala 2.11.7 for MacOS (链接：<a href="https://downloads.lightbend.com/scala/2.11.7/scala-2.11.7.tgz">https://downloads.lightbend.com/scala/2.11.7/scala-2.11.7.tgz</a> ) , 重命名为scala后移动到系统目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv scala-2.11.7 scala     <span class="comment"># 重命名 Scala 目录</span></span><br><span class="line">mv scala /usr/<span class="built_in">local</span>/share <span class="comment"># 移动到系统文件夹</span></span><br></pre></td></tr></table></figure><p><code>sudo vim ~/.bash_profile</code>修改系统环境变量，在文件最后添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/usr/local/share/scala/bin&quot;</span></span><br></pre></td></tr></table></figure><p>保存退出，重启终端后输入scala，如果安装正常应该输出如下信息：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831112555.png" alt=""></p><h2 id="2-将Scala-object打包为可执行的jar文件（使用IntelliJ-IDEA-Maven）">2. 将Scala object打包为可执行的jar文件（使用IntelliJ IDEA + Maven）</h2><p>Maven是一种管理和构建Java项目的工具，由于Scala源于Java并可以运行在Java虚拟机之上，所以Scala的class文件自然也可以使用Maven进行管理和构建。Maven可以在终端中使用（brew install maven），本文主要介绍更为简便的使用IDE+Maven的方法。</p><h3 id="2-1-安装IDEA的Scala插件">2.1. 安装IDEA的Scala插件</h3><p>打开IntelliJ IDEA，首先需要安装Scala的plugin。在启动窗口的configurations或者项目窗口左上角的IDEA-Preferences里找到Plugin，搜索scala然后安装如图插件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831112624.png" alt=""></p><h3 id="2-2-新建Maven项目">2.2. 新建Maven项目</h3><p>新建一个项目，项目类型选择Maven。下一步-输入项目名称-Finish。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831112750.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831112809.png" alt=""></p><p>项目结构如图所示。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831112826.png" style="zoom:67%;" /><h2 id="2-3-配置Scala-Library">2.3. 配置Scala Library</h2><p>任务栏菜单File-Project Structure，对话框中选择Global Libraries，点击加号-Scala SDK，然后Browse选择scala文件夹。</p><p>（小tips：MacOS找不到系统隐藏文件/目录可以<strong>command+shift+G</strong>直接输入路径。）</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831112911.png" style="zoom: 67%;" /><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831112941.png" style="zoom: 50%;" /><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831112958.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113020.png" alt=""></p><h2 id="2-4-修改Maven项目相关设置">2.4. 修改Maven项目相关设置</h2><p>在项目名称处右键选择“Add Framework Support”，在弹出的对话框中选择Scala，确认版本无误后点确定。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113238.png" style="zoom:67%;" /><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113303.png" alt=""></p><p>分别右键src文件夹中main和test目录下的“java”文件夹，右键refactor-rename，勾选两个复选框，分别修改名字为scala</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113321.png" style="zoom:67%;" /><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113332.png" style="zoom: 67%;" /><p>找到project目录下的pom.xml文件，接下来需要进行一些修改：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113405.png" alt=""></p><p>打开网页https://mvnrepository.com/artifact/org.apache.spark/spark-sql_2.11/2.1.2 , 找到下图文本框中的部分，全选复制。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113431.png" alt=""></p><p>在pom.xml中的<code>&lt;version&gt;</code>属性下面新建一个<code>&lt;dependencies&gt;&lt;/dependencies&gt;</code>属性，把复制的代码粘贴进去，也可以直接复制下面代码块粘贴到version后面。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-sql --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-sql_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终的pom文件应该长这样</strong>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113452.png" alt=""></p><p>如果org.apache.spark有问题的话可以参考<a href="https://blog.csdn.net/helloworld0906/article/details/89247002">文章1</a>和<a href="https://blog.csdn.net/qq_42400267/article/details/103409701?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf">文章2</a>想办法自己导入一下相关的jar包。简单来说就是：</p><ol><li><p>下载https://archive.apache.org/dist/spark/spark-2.1.2/spark-2.1.2-bin-hadoop2.7.tgz 并解压</p></li><li><p>在IDEA的菜单File-Project Structure-Modules里点击右下角的加号-JARs or directory，导入刚才解压的文件夹/jar/目录下面的所有jar包，应该就不会报错了。</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113526.png" alt=""></p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113544.png" style="zoom: 50%;" /><h2 id="2-5-新建Scala-Object">2.5. 新建Scala Object</h2><p>我们以一个小写字母转大写的函数为例。在目录下的src-main-scala右键，新建名为com.spark.utilities的package。在新建的package右键New-Scala class，类型选择object，命名为MyUpper。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113606.png" style="zoom:50%;" /><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113623.png" style="zoom:50%;" /><p>代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spark.utilities</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.api.java.<span class="type">UDF1</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUpper</span> <span class="keyword">extends</span> <span class="title">UDF1</span>[<span class="type">String</span>, <span class="type">String</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">call</span></span>(input: <span class="type">String</span>):<span class="type">String</span> = input.toUpperCase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-编译-jar文件">2.6. 编译.jar文件</h2><p>在File-Program Structure-Artifacts点击加号-JAR-From modules with dependencies。在弹出的对话框直接OK。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113659.png" alt=""></p><p>此时右边应该会出现这样的一大堆东西。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113741.png" alt=""></p><p>我们把左边这一列上面的内容都删了，只留最下面的xxxxx output，最后应该是下面这样</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113823.png" alt=""></p><p>点ok或者apply保存设置，回到主界面，Build-Build Artifacts-xxx:jar-Build，然后应该就开始构建jar文件了</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113843.png" style="zoom:50%;" /><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831113857.png" style="zoom:50%;" /><p>最后在目录下面应该出现了out-artifact-xxx.jar文件，说明操作正确。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831114051.png" style="zoom:50%;" /><h2 id="3-在PySpark脚本中调用udf">3. 在PySpark脚本中调用udf</h2><p>示例代码（注意修改jar文件的路径）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession, SQLContext</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> *</span><br><span class="line">spark = SparkSession.builder \</span><br><span class="line">        .config(<span class="string">&quot;spark.driver.extraClassPath&quot;</span>, <span class="string">&quot;JAR文件所在的目录/ScalaUtilities.jar&quot;</span>) \</span><br><span class="line">        .getOrCreate()</span><br><span class="line">sqlcontext = SQLContext(spark)</span><br><span class="line">sqlcontext.registerJavaFunction(<span class="string">&quot;my_udf&quot;</span>, <span class="string">&quot;com.first.spark.MyUpper&quot;</span>, StringType())</span><br><span class="line">spark.sql(<span class="string">&quot;&quot;&quot;SELECT my_udf(&#x27;abeD123okoj&#x27;)&quot;&quot;&quot;</span>).show()</span><br></pre></td></tr></table></figure><p>输出正确即证明环境配置、代码调用都准确无误，之后就可以用scala实现一些udf啦。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200831114114.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 大数据工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
            <tag> pyspark </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-分析与绘图（4）：对twitter数据进行文本挖掘</title>
      <link href="/2020/08/23/text-mining-twitter/"/>
      <url>/2020/08/23/text-mining-twitter/</url>
      
        <content type="html"><![CDATA[<p><a href="https://davekim3872.github.io/2020/08/20/data-visulization-intro/">上一篇：R语言-分析与绘图（3）：可视化入门</a></p><p>社交媒体的数据虽然大部分以文字形式呈现，但是其中包含的巨量信息在舆情分析、市场调研乃至政治手腕方面都能够发挥巨大的作用，具有深不可测的潜力，我们在本章节将要学习如何挖掘和分析这些数据，主要目的是复习之前学习的知识并<strong>新引入一些函数作为实际操作中的tricks</strong>，所以不要认为是单纯的复习课而已。</p><p>在这一部分我们需要用到一个新的包：jsonlite. 它可以让我们读取json数据并转换成R语言方便处理的格式。json格式可以理解成一种特殊的表格——字典（dict）格式，它的基本表达形式是“key：value”，表达了本条记录中的某个字段的值为某某。</p><p>在终端中输入以下命令安装jsonlite：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">&#x27;jsonlite&#x27;</span>)</span><br></pre></td></tr></table></figure><p>同样地，我们仍然需要用tidyverse处理dataframe数据，所以在教程的最开始我们先导入jsonlite和tidyverse两个包：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(jsonlite)</span><br><span class="line"><span class="keyword">library</span>(tidyverse)</span><br></pre></td></tr></table></figure><h2 id="分析懂王的推文">分析懂王的推文</h2><h3 id="读取json文件并转为dataframe">读取json文件并转为dataframe</h3><p>一切从简，本文主要是为了复习并综合实践前文所述的内容，因此不探讨如何抓取twitter timeline并导出为json格式的文件（假设你有一个助手使用twitterR工具包和twitter的auth key API已经帮你抓好并保存成了json文件，可以在这里下载），我们直接进行读取json文件的操作。</p><p>jsonlite包读取json文件的方法如下方代码所示：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文件DT_tweets.json并且转换为dataframe</span></span><br><span class="line">Trumptweets &lt;- fromJSON(<span class="string">&quot;DT_tweets.json&quot;</span>) %&gt;% as.data.frame</span><br><span class="line">head(Trumptweets)</span><br></pre></td></tr></table></figure><p>结果如下：</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200823184555.png" style="zoom:50%;" /><p>通过字段名称（key）和值（value）可以清晰地看出各列代表的意思，比如前面分别是发送时间、点赞数、粉丝数、推文id、转发数和发送源（设备、客户端或者网站），最右边因为太长了没有显示完整的<code>text &lt;chr&gt;</code>字段，代表的就是每条推文的文本内容：</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200823210055.png" style="zoom:50%;" /><p>如果想取出第一行的文本内容和点赞数，按照原来的方法，代码是：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trumptweets[<span class="number">1</span>,c(<span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;favourite_count&#x27;</span>)]</span><br></pre></td></tr></table></figure><h3 id="找出点赞最多的推文">找出点赞最多的推文</h3><p>用<code>which.max()</code>函数找出懂王点赞数最多的tweet。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果这几行看不懂，建议抓紧复习第一篇</span></span><br><span class="line">idx &lt;- Trumptweets %&gt;%</span><br><span class="line">    summarise(which.max(favourite_count)) %&gt;%</span><br><span class="line">    as.numeric()</span><br><span class="line">Trumptweets[idx, c(<span class="string">&#x27;favourite_count&#x27;</span>,<span class="string">&#x27;retweet_count&#x27;</span>)]</span><br></pre></td></tr></table></figure><h3 id="文本拼接的新方法">文本拼接的新方法</h3><p>之前有学过拼接文本的方法<code>paste()</code>，而在实际应用中用到<code>cat()</code>的次数可能更多些。</p><p><code>cat()</code>的用法其实差不多，区别是可以用<code>sep='separator'</code>定义拼接的方法，也就是定义分隔符是什么。python里学过<code>\n</code>是换行符的意思，所以如果我想用换行的方式拼接文本，就在括号内的最后加一个<code>sep=&quot;\n&quot;</code>就可以：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat(<span class="string">&#x27;If you forgot how to concatenate strings, this may also help you.&#x27;</span>,<span class="string">&#x27;The most popular of Trumps tweets is:&#x27;</span>, Trumptweets[idx, <span class="string">&#x27;text&#x27;</span>], sep=<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200823222510.png" alt=""></p><h3 id="统计关于字数的信息">统计关于字数的信息</h3><p>先计算每篇推文的字数。tidyverse有一个统计字符串长度的函数叫<code>nchar(string_name)</code>，除此之外，如果第一篇看透了就没啥好讲的哈！直接上代码：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Trumtweets &lt;- Trumptweets %&gt;%<span class="comment"># 定义输入和输出</span></span><br><span class="line">    mutate(length = nchar(text)) <span class="comment"># 新增一列length存储text的长度</span></span><br><span class="line"></span><br><span class="line">Trumptweets %&gt;%<span class="comment"># 只展示，不保存到变量</span></span><br><span class="line">select(length) %&gt;%<span class="comment"># 选择要显示的列为新增的length列</span></span><br><span class="line">    head()<span class="comment"># 显示前6行</span></span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200823222825.png" style="zoom: 50%;" /><p>接下来计算平均字数，这用到了之前学过的<code>mean()</code>函数，下面的代码计算出来应该是159.3：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算字数这一列的平均值并保留一位小数</span></span><br><span class="line">avg &lt;- round(mean(Trumptweets$length), <span class="number">1</span>)</span><br><span class="line">print(avg)</span><br></pre></td></tr></table></figure><p>最后计算一下超过140字的推文数量，<code>filter()</code>可以帮助我们按照不等式条件筛选这些推文，而计算数量则可以使用<code>count()</code>函数实现。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">len140 &lt;- Trumptweets %&gt;%</span><br><span class="line">    filter(length &gt; <span class="number">140</span>) %&gt;% <span class="comment"># 条件筛选</span></span><br><span class="line">    count() <span class="comment"># 计数</span></span><br><span class="line">print(len140)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200824094112.png" style="zoom:50%;" /><p>可以看到一共有3534条推文长达140字以上。懂王的屁话果然多。</p><h3 id="分析关键词信息">分析关键词信息</h3><p>我们想找出懂王的twitter中有多少关于“boarder”和“immigration”的推文，毕竟这是他老人家永恒的主题。为了去查找包含这些关键词的推文，我们使用函数<code>str_detect()</code>来进行规则匹配，以我们的任务举例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ind = str_detect(Trumptweets$text,regex(<span class="string">&quot;border|immigration&quot;</span>, ignore_case = <span class="literal">TRUE</span>))</span><br></pre></td></tr></table></figure><p>函数的第一部分参数<code>Trumptweets$text</code>指示了我们搜寻的范围，第二部分参数是一个正则表达式语法<code>regex()</code>，在这里面的第一个参数<code>&quot;border | immigration&quot;</code>代表我们想要查找的关键词是“border”或者“immigration”，当然你也可以只写一个词；<code>ignore_case=TRUE/FALSE</code>代表是否忽略大小写规则，因为懂王很喜欢upper-case关键词发推文，所以我们当然要ignore大小写区别。TRUE和FALSE也可以写成T和F。完整代码如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出一个代表每行text是否包含border或者immigration关键词的TRUE/FALSE序列</span></span><br><span class="line">ind &lt;- str_detect(Trumptweets$text,regex(<span class="string">&quot;border|immigration&quot;</span>, ignore_case = <span class="literal">TRUE</span>))</span><br><span class="line"><span class="comment"># 打印序列前六个（前六行是否包含这两个关键词）</span></span><br><span class="line">head(ind)</span><br><span class="line"><span class="comment"># 打印ind为TRUE（即包含这两个关键词的）前六个text</span></span><br><span class="line">head(Trumptweets$text[ind])</span><br><span class="line"><span class="comment"># 最后两行对ind为TRUE的条目（包含这两个关键词的推文条目）进行计数</span></span><br><span class="line">A=Trumptweets$text[ind]</span><br><span class="line">print(length(A))</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200824095824.png" style="zoom:50%;" /><p>除了像上述这样处理，我们还可以从整个数据集中生成一些包含某个关键词的子集，使用<code>str_subset()</code>函数可以轻松实现这一点：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个关于移民话题的text子集</span></span><br><span class="line">immigration &lt;- str_subset(Trumptweets$text,<span class="string">&quot;immigration&quot;</span>)</span><br><span class="line"><span class="comment"># 生成一个关于就业话题的text子集</span></span><br><span class="line">jobs &lt;- str_subset(Trumptweets$text,<span class="string">&quot;employment&quot;</span>)</span><br><span class="line"><span class="comment"># 尝试输出jobs子集的前六行</span></span><br><span class="line">head(jobs)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200824095857.png" style="zoom:50%;" /><p>你可能已经注意到了，上面两种函数<code>str_detect()</code>和<code>str_subset()</code>只能针对一个列<code>Trumptweets$text</code>进行操作，而且输出结果丢失了其他列的所有信息。如果既想进行查找，又想保留其他列的信息，可以把<code>str_detect()</code>函数与<code>filter()</code>函数结合使用，或者直接作为tibble的下标中的row index。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接作为行标row index（记！得！留！逗！号！）</span></span><br><span class="line">immigration_all &lt;- Trumptweets[str_detect(Trumptweets$text,regex(<span class="string">&quot;immigration&quot;</span>, ignore_case=<span class="literal">T</span>)),]</span><br><span class="line"><span class="comment"># 或者使用filter()</span></span><br><span class="line">immigration_all &lt;- Trumptweets %&gt;%</span><br><span class="line">        filter(str_detect(text,regex(<span class="string">&quot;immigration&quot;</span>, ignore_case=<span class="literal">T</span>)))</span><br><span class="line">head(immigration_all)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，条件表达式成立的标准是当其输出为TRUE的时候，即“条件 == TRUE”则成立；而在所有编程语言中默认“条件”等价于“条件 == TRUE”，“!条件”等价于“条件 == FALSE”。举例说明：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如</span></span><br><span class="line">immigration_all &lt;- Trumptweets %&gt;%</span><br><span class="line">        filter(str_detect(text,regex(<span class="string">&quot;immigration&quot;</span>, ignore_case=<span class="literal">T</span>)))</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">immigration_all &lt;- Trumptweets %&gt;%</span><br><span class="line">        filter(str_detect(text,regex(<span class="string">&quot;immigration&quot;</span>, ignore_case=<span class="literal">T</span>)) == <span class="literal">TRUE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相反地</span></span><br><span class="line">immigration_all &lt;- Trumptweets %&gt;%</span><br><span class="line">        filter(!str_detect(text,regex(<span class="string">&quot;immigration&quot;</span>, ignore_case=<span class="literal">T</span>)))</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">immigration_all &lt;- Trumptweets %&gt;%</span><br><span class="line">        filter(str_detect(text,regex(<span class="string">&quot;immigration&quot;</span>, ignore_case=<span class="literal">T</span>)) == <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p>另一个非常有用的函数是<code>str_extract()</code>，它和<code>str_detect()</code>的用法相似，唯一不同就是它输出的序列是包含某些关键词的序列中的每一条究竟包含了哪个关键词。如果理解困难的话可以直接看例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出每一行包含了mexico、border、wall三个词当中的哪些，如果均不包含则输出NA</span></span><br><span class="line">border_wall &lt;- str_extract(Trumptweets$text, regex(<span class="string">&quot;mexico|border|wall&quot;</span>, ignore_case=<span class="literal">T</span>))</span><br><span class="line"><span class="comment"># 前几条推文都不包含所以是NA</span></span><br><span class="line">head(border_wall)</span><br><span class="line"><span class="comment"># 用na.omit()去掉不包含这两个关键词的NA条目，就打印出来了包含这些关键词的前几条推文分别包含哪个关键词</span></span><br><span class="line">head(na.omit(border_wall))</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200824101451.png" style="zoom:50%;" /><p>函数<code>str_starts()</code>和<code>str_ends()</code>分别代表寻找以某些关键词开头或结尾的文本，其用法和上面的<code>str_subset()</code>一样，都是输入一列文本+关键词；输出则是一个TRUE或FALSE组成的、和整个数据集等长的序列。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检索以“BIG”开头的推文</span></span><br><span class="line">BIG &lt;- str_starts(Trumptweets$text, <span class="string">&quot;BIG&quot;</span>)</span><br><span class="line"><span class="comment"># TRUE/FALSE序列的长度就是整个数据集的长度，因为要给每一行一个判定结果（有还是没有）</span></span><br><span class="line">length(BIG)</span><br><span class="line"><span class="comment"># 但是sum函数统计的就是TRUE的数量了，这句话等价于sum(BIG==TRUE)</span></span><br><span class="line">sum(BIG)</span><br></pre></td></tr></table></figure><p>我们发现懂王居然只发了一条BIG开头的推特，非常的鹅妹子嘤。上面这个<code>sum()</code>函数的用法也可以拓展到其他几个字符串判定函数上，我们举几个简单的例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">immigration &lt;- sum(str_detect(Trumptweets$text,regex(<span class="string">&quot;immigration&quot;</span>, ignore_case=<span class="literal">T</span>)))</span><br><span class="line">jobs &lt;- sum(str_detect(Trumptweets$text,regex(<span class="string">&quot;employment&quot;</span>, ignore_case=<span class="literal">T</span>)))</span><br><span class="line">other &lt;- sum(!str_detect(Trumptweets$text,regex(<span class="string">&quot;employment|immigration&quot;</span>, ignore_case=<span class="literal">T</span>)))</span><br><span class="line"></span><br><span class="line">paste(<span class="string">&quot;the number of tweets about immigration =&quot;</span>, immigration)</span><br><span class="line">paste(<span class="string">&quot;the number of tweets about employment =&quot;</span>, jobs)</span><br><span class="line">paste(<span class="string">&quot;the number of tweets NOT about employment or immigration =&quot;</span>, other)</span><br></pre></td></tr></table></figure><p>这几行我刻意不写注释了。聪明的你，一定知道我在干什么。输出是下面这样……算了输出我也不给了，不如你自己来跑一下。</p><p>做了这么多分析，也该给老板贡献一点可视化结果了，我们用上次学的ggplot2画个图。首先计算四个数据：</p><ul><li>包含边境、移民关键词的twitter数量</li><li>包含工作、失业关键词的twitter数量</li><li>不包含上述关键词的twitter数量</li><li>懂王推文的总数（使用<code>nrow()</code>函数）</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含边境、移民关键词的twitter数量</span></span><br><span class="line">number_border &lt;- sum(str_detect(Trumptweets$text,regex(<span class="string">&quot;border|immigration|wall&quot;</span>, ignore_case=<span class="literal">T</span>)))</span><br><span class="line"><span class="comment"># 包含工作、失业关键词的twitter数量</span></span><br><span class="line">number_jobs &lt;- sum(str_detect(Trumptweets$text,regex(<span class="string">&quot;job|work|unemployment&quot;</span>, ignore_case=<span class="literal">T</span>)))</span><br><span class="line"><span class="comment"># 不包含上述关键词的twitter数量</span></span><br><span class="line">number_other &lt;- sum(!str_detect(Trumptweets$text,regex(<span class="string">&quot;job|work|unemployment|border|immigration|wall&quot;</span>, ignore_case=<span class="literal">T</span>)))</span><br><span class="line"><span class="comment"># 懂王推文的总数（使用nrow函数）</span></span><br><span class="line">tot_tweets &lt;- nrow(Trumptweets)</span><br></pre></td></tr></table></figure><p>然后分别计算前三个数据占推文总数的百分比，并新建一个data.frame把这三个值放进去以方便画图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">perc_border=(number_border/tot_tweets)*<span class="number">100</span></span><br><span class="line">perc_jobs=(number_jobs/tot_tweets)*<span class="number">100</span></span><br><span class="line">perc_other=(number_other/tot_tweets)*<span class="number">100</span></span><br><span class="line"><span class="comment"># 新建一个为了画图的dataframe，抽象理解一下，两行分别是label和perc，三列分别是xxxxx</span></span><br><span class="line">perc_all = data.frame(labels=c(<span class="string">&#x27;Border Security&#x27;</span>,<span class="string">&#x27;Others&#x27;</span>, <span class="string">&#x27;Jobs&#x27;</span>),</span><br><span class="line">                      percentage=c(perc_border,perc_other,perc_jobs))</span><br></pre></td></tr></table></figure><p>最后画图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  先画条形图,记得fill=labels是按照label区分填充色的意思</span></span><br><span class="line">bp&lt;- ggplot(perc_all, aes(x=<span class="string">&quot;&quot;</span>,y=percentage, fill=labels))+</span><br><span class="line">  geom_bar(width = <span class="number">1</span>, stat = <span class="string">&quot;identity&quot;</span>) + xlab(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># 再转成以百分比为轴的饼状图</span></span><br><span class="line">pie &lt;- bp + coord_polar(<span class="string">&quot;y&quot;</span>, start=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 调整尺寸</span></span><br><span class="line">options(repr.plot.width=<span class="number">5</span>, repr.plot.height=<span class="number">5</span>)</span><br><span class="line">print(pie)  </span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200824103742.png" style="zoom:50%;" /><h3 id="分析时间轴信息">分析时间轴信息</h3><p>这里需要一个叫做lubridate的包，我们已经提前装好了，直接引入即可。</p><p>这个包有一个函数<code>ymd_hms()</code>，给它输入一个格式为<code>年-月-日 时:分:秒</code>时间字符串（你说巧不巧我们刚好是这个，其实这是标准时间格式的一种啦），它可以给你输出一个时间对象。这个时间对象和时间字符串长的差不多，但是最大区别是你可以通过某些方法取出它的日期或者小时等数据，比如我们这里只想分析日期，你就可以用<code>date(对象名称)</code>函数从时间对象里取出日期。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入lubricate</span></span><br><span class="line"><span class="keyword">require</span>(lubridate)</span><br><span class="line"></span><br><span class="line">Trumptweets &lt;- Trumptweets %&gt;% </span><br><span class="line"><span class="comment"># 把字符串格式的时间转为时间对象格式</span></span><br><span class="line">    mutate(Date = ymd_hms(created_at))</span><br><span class="line">head(Trumptweets[<span class="string">&quot;Date&quot;</span>])</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200824104459.png" style="zoom:50%;" /><p>我们想要按照日期分组，分析每天的点赞和转发数。使用上文说的<code>date(对象名称)</code>函数从时间对象里取出日期，用这玩意做一个<code>group_by()</code>然后用<code>summarize()</code>包裹<code>sum()</code>去求一下点赞和转发各自的数量之和。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们直接输出一个新表叫grouped_tweets</span></span><br><span class="line">grouped_tweets &lt;- Trumptweets %&gt;%</span><br><span class="line">                <span class="comment"># 用date()可以取日期，类似地还可以用year()取年，用month()取月份之类的，自己试着玩</span></span><br><span class="line">                    group_by(days=date(Date)) %&gt;%</span><br><span class="line">                    <span class="comment"># 计算转发、点赞数</span></span><br><span class="line">                        summarise(retweets = sum(retweet_count),</span><br><span class="line">                                 Likes = sum(favourite_count))</span><br><span class="line">head(grouped_tweets)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200824104947.png" style="zoom:50%;" /><p>最后，用grouped_tweets这么棒的一个表格画个折线图反应点赞和转发随着日期的变化趋势吧。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画个点赞曲线，x轴是日期</span></span><br><span class="line">pl &lt;- ggplot(grouped_tweets, aes(x=days,y=Likes)) + geom_line(aes(colour=<span class="string">&quot;Likes&quot;</span>))</span><br><span class="line"><span class="comment"># 再加个转发曲线，x轴还是日期</span></span><br><span class="line">pl &lt;- pl + geom_line(aes(x=days,y=retweets, colour = <span class="string">&quot;retweets&quot;</span>))</span><br><span class="line"><span class="comment"># 手动定义一下颜色（真的脱裤子放屁，为啥不直接在上面写颜色）</span></span><br><span class="line">pl &lt;- pl + scale_colour_manual(name=<span class="string">&#x27;&#x27;</span>, values=c(<span class="string">&#x27;retweets&#x27;</span>=<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;Likes&#x27;</span>=<span class="string">&#x27;red&#x27;</span>))</span><br><span class="line"><span class="comment"># 写一下x轴和y轴标签</span></span><br><span class="line">pl &lt;- pl + xlab(<span class="string">&quot;Date and time&quot;</span>) + ylab(<span class="string">&quot;Daily retweets, likes and fans&quot;</span>)</span><br><span class="line">print(pl)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200824105252.png" style="zoom:50%;" /><p>原来这货真的一直在涨粉吗……？</p>]]></content>
      
      
      <categories>
          
          <category> R语言数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Jsonlite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用MacOS内建的工具录屏（解决录制无声音问题）</title>
      <link href="/2020/08/21/mac-screen-rec/"/>
      <url>/2020/08/21/mac-screen-rec/</url>
      
        <content type="html"><![CDATA[<h2 id="Mojave世代引入的截图-录屏工具">Mojave世代引入的截图/录屏工具</h2><p>在MacOS 10.14 Mojave或者更高版本上，苹果引入了系统内建的截屏和录屏工具，在任何情况下使用shift+command+5就可以呼出操控面板。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200821140416.png" alt=""></p><p>左边三项分别是截取全屏、窗口和选定区域，右边两项分别是录制全屏和选定区域，点击所需选项后再按一下最右边出现的“捕捉”或者“录制”就可以截屏或者录屏了。开始录屏后最上方状态栏会有一个停止录制的按钮，按一下就可以停止录制。视频或者截图文件会自动保存在桌面。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200821140729.png" alt=""></p><p>但是，系统自带的录屏无法录制到电脑的声音，在最右边的选项中也只能看到麦克风的选项，也就是说要么没声音，要么录的就是你说的话，反正你电脑播放的声音我们是录不到。</p><h2 id="录制系统声音的解决方案">录制系统声音的解决方案</h2><p>接下来严格按照步骤操作，你就能录到系统的声音了。</p><p>首先在下载安装<a href="https://www.macwk.com/soft/loopback">Loopback</a>这个软件（有能力的请支持正版），打开软件点击右上角的trial license输入提供的激活码激活软件。</p><p>软件界面长这样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200821141451.png" alt=""></p><p>假设我们要录制浏览器播放的视频（就选择录制全屏好了），在Loopback界面的sources点击加号，选择你使用的浏览器（我用的是edge），当然不一定是浏览器，如果是zoom或者腾讯会议之类的东西也同理。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200821141650.png" style="zoom:50%;" /><p>然后界面就变成了这个样子：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200821141731.png" alt=""></p><p>播放视频的时候能看到你的应用程序的声音在波动，可以点下面的opotions调节音量，这个决定了之后录屏中的声音大小：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200821141911.png" alt=""></p><p>为了保证你自己在录屏的时候还能听到声音，在最右边的monitors加入输出设备，一般是internal speakers代表电脑扬声器和有线耳机，如果你在用airpods的话，连接上airpods后可以看到有airpods，加上就好了；反正你想用什么听就加上什么东西。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200821142232.png" style="zoom:50%;" /><p>然后播放时的界面就变成这样了：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-08-21%20%E4%B8%8B%E5%8D%882.23.07.png" alt=""></p><p>另外比较灵活的是，输入、输出、监控的通道除了可以在选中后通过command+backspace删除之外，还可以手动控制开关。这个你们可以自己尝试。</p><p>准备完毕，接下来开始录屏，<strong>shift+command+5呼出控制台，选择录制整个屏幕，在右边的选项-麦克风一栏选择Loopback Audio</strong>。</p><p>大功告成，可以开始录屏了。建议在正式录屏之前<u>先测试一下</u>，免得录了一个小时发现没设置好，人间惨剧。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具和教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
            <tag> 系统工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-分析与绘图（3）：可视化入门</title>
      <link href="/2020/08/20/data-visulization-intro/"/>
      <url>/2020/08/20/data-visulization-intro/</url>
      
        <content type="html"><![CDATA[<p>上一篇：<a href="https://davekim3872.github.io/2020/08/15/webpages-analyze/">R语言-分析与绘图（2）：使用rvest库抓取和分析网页信息</a></p><p>@Keren Wang：函数名称不用记，用的时候可以查；但是为了对名称、功能和用法有印象，还是建议多写代码训练一下肌肉记忆，不然考试的时候可能查也来不及。</p><p>学习如何收集和分析数据是商业/金融/市场领域中的一项关键技能，但是如果没有有效表征结果的能力，这些数据可能毫无意义。“数据可视化”一词描述了将信息在可视化的上下文中展现出来的过程，以帮助我们以更完整和有效的方式理解数据。 我们可以用图表可以显示多个变量之间的关系，或者以图形方式突出显示不同数据集之间的差异。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820100952.png" alt=""></p><p>本模块介绍了一些使用R绘图的基本技术，特别是扩展了使用tidyverse工具包中的ggplot2的知识。我们将使用来自NASA系外行星档案的真实天文数据来支持本章节的数据可视化学习。除了我们介绍到的内容，你也可以在 <a href="http://www.cookbook-r.com/Graphs/">R cookbook for graphs</a> 获取有用的学习资源。</p><p>首先，我们加载tidyverse库并读取行星数据表<code>planets.csv</code>。在提前被告知该表有32行是表头（介绍表格的内容，而非有用的数据）的情况下，我们使用<code>read_delim()</code>函数中的<code>skip = 32</code>参数来指定“在读取数据前先跳过32行”。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(tidyverse)</span><br><span class="line">kdf &lt;- read_delim(<span class="string">&quot;planets.csv&quot;</span>, delim=<span class="string">&quot;,&quot;</span>, skip=<span class="number">32</span>)</span><br><span class="line">head(kdf)</span><br></pre></td></tr></table></figure><h2 id="示例：使用ggplot2库绘制第一个曲线图">示例：使用ggplot2库绘制第一个曲线图</h2><h3 id="ggplot-函数"><code>ggplot()</code> 函数</h3><p>ggplot2是tidyverse里绘图的库。<code>ggplot(data=df, aes(x,y))</code> 函数的作用是使用<code>df</code>这张表中的<code>x</code>和<code>y</code>两列作为x轴和y轴，在二维坐标系下绘制图像。如果写成<code>data = NULL</code>，则需要自己建立两个长度相同的向量x和向量y作为横轴和纵轴的坐标。注意，这一步只是绘制出来了画布<code>p</code>，我们还没有定义曲线。如果只执行<code>ggplot()</code> 函数，我们将会得到下面的结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立两个向量x和y作为横轴和纵轴坐标</span></span><br><span class="line">x &lt;- c(<span class="number">0.</span>  ,  <span class="number">0.15</span>,  <span class="number">0.3</span> ,  <span class="number">0.45</span>,  <span class="number">0.6</span> ,  <span class="number">0.75</span>,  <span class="number">0.9</span> ,  <span class="number">1.05</span>,  <span class="number">1.2</span> ,</span><br><span class="line">        <span class="number">1.35</span>,  <span class="number">1.5</span> ,  <span class="number">1.65</span>,  <span class="number">1.8</span> ,  <span class="number">1.95</span>,  <span class="number">2.1</span> ,  <span class="number">2.25</span>,  <span class="number">2.4</span> ,  <span class="number">2.55</span>,</span><br><span class="line">        <span class="number">2.7</span> ,  <span class="number">2.85</span>)</span><br><span class="line">y &lt;- c(-<span class="number">0.51</span>, -<span class="number">0.29</span>,  <span class="number">1.13</span>, -<span class="number">2.06</span>, -<span class="number">0.63</span>, -<span class="number">0.36</span>,  <span class="number">1.41</span>, -<span class="number">0.24</span>,  <span class="number">1.27</span>,</span><br><span class="line">        <span class="number">0.37</span>,  <span class="number">0.23</span>,  <span class="number">2.96</span>,  <span class="number">2.54</span>,  <span class="number">1.11</span>,  <span class="number">2.92</span>,  <span class="number">0.95</span>,  <span class="number">2.17</span>,  <span class="number">3.41</span>,</span><br><span class="line">        <span class="number">4.87</span>,  <span class="number">5.36</span>) </span><br><span class="line"> </span><br><span class="line">p &lt;- ggplot(<span class="literal">NULL</span>,aes(x,y)) <span class="comment"># NULL表示我们不从表中取数据，直接使用自己创建的向量作为数据源</span></span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820103347.png" style="zoom: 50%;" /><h3 id="用geom-line-函数添加曲线">用<code>geom_line()</code>函数添加曲线</h3><p>接下来我们需要在画布<code>p</code>上添加元素（点、线等）。ggplot2库规定我们使用加号<code>+</code>表示在图上增加元素。比如想要在刚才建立的画布<code>p</code>上绘制一个曲线，我们需要在<code>p</code>上使用加号叠加一个<code>geom_line()</code>函数，默认画的是黑色实线。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(<span class="literal">NULL</span>,aes(x,y)) <span class="comment"># NULL表示我们不从表中取数据，直接使用自己创建的向量作为数据源</span></span><br><span class="line">p &lt;- p + geom_line() <span class="comment"># 画上一条曲线</span></span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820104017.png" style="zoom:50%;" /><p>曲线出来了，但不是很好看。这是因为我们在<code>geom_line()</code>函数中没有定义样式。下面尝试把刚才的代码修改一下，把绘制曲线的函数改为<code>geom_line(colour = 'red', linetype=2)</code>，其中<code>colour = 'red'</code>代表曲线颜色是红色，<code>linetype=2</code>代表我们使用长虚线（你可以试着修改这个数字，看看各个数字分别代表什么样式）。当然你也可以只定义颜色或者只定义线条种类。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(<span class="literal">NULL</span>,aes(x,y)) <span class="comment"># NULL表示我们不从表中取数据，直接使用自己创建的向量作为数据源</span></span><br><span class="line">p &lt;- p + geom_line(colour=<span class="string">&quot;red&quot;</span>, linetype=<span class="number">2</span>) <span class="comment"># 画上一条曲线</span></span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820104626.png" style="zoom:50%;" /><h3 id="用geom-point-函数添加坐标点">用<code>geom_point()</code>函数添加坐标点</h3><p>曲线画完了，如果我们想把这些点都标出来呢？同样地，ggplot2也提供了<code>geom_point()</code>函数用来画点，默认画的是黑色实心点。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(<span class="literal">NULL</span>,aes(x,y)) <span class="comment"># NULL表示我们不从表中取数据，直接使用自己创建的向量作为数据源</span></span><br><span class="line">p &lt;- p + geom_line(colour=<span class="string">&quot;red&quot;</span>, linetype=<span class="number">2</span>) <span class="comment"># 画上一条曲线</span></span><br><span class="line">p &lt;- p + geom_point() <span class="comment"># 把点也画上</span></span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820105101.png" style="zoom:50%;" /><p>如果你觉得不好看，当然也可以自定义点的样式。我们把画点的函数修改为<code>geom_point(colour=&quot;blue&quot;, shape=0)</code>，<code>colour=&quot;blue&quot;</code>含义为点的颜色为蓝色，<code>shape=0</code>的含义为正方形空心点（你可以试着修改这个数字，看看各个数字分别代表什么样式）。同样地，你也可以只定义颜色或者形状。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立两个向量x和y作为横轴和纵轴坐标</span></span><br><span class="line">x &lt;- c(<span class="number">0.</span>  ,  <span class="number">0.15</span>,  <span class="number">0.3</span> ,  <span class="number">0.45</span>,  <span class="number">0.6</span> ,  <span class="number">0.75</span>,  <span class="number">0.9</span> ,  <span class="number">1.05</span>,  <span class="number">1.2</span> ,</span><br><span class="line">        <span class="number">1.35</span>,  <span class="number">1.5</span> ,  <span class="number">1.65</span>,  <span class="number">1.8</span> ,  <span class="number">1.95</span>,  <span class="number">2.1</span> ,  <span class="number">2.25</span>,  <span class="number">2.4</span> ,  <span class="number">2.55</span>,</span><br><span class="line">        <span class="number">2.7</span> ,  <span class="number">2.85</span>)</span><br><span class="line">y &lt;- c(-<span class="number">0.51</span>, -<span class="number">0.29</span>,  <span class="number">1.13</span>, -<span class="number">2.06</span>, -<span class="number">0.63</span>, -<span class="number">0.36</span>,  <span class="number">1.41</span>, -<span class="number">0.24</span>,  <span class="number">1.27</span>,</span><br><span class="line">        <span class="number">0.37</span>,  <span class="number">0.23</span>,  <span class="number">2.96</span>,  <span class="number">2.54</span>,  <span class="number">1.11</span>,  <span class="number">2.92</span>,  <span class="number">0.95</span>,  <span class="number">2.17</span>,  <span class="number">3.41</span>,</span><br><span class="line">        <span class="number">4.87</span>,  <span class="number">5.36</span>) </span><br><span class="line"> </span><br><span class="line">p &lt;- ggplot(<span class="literal">NULL</span>,aes(x,y)) <span class="comment"># NULL表示我们不从表中取数据，直接使用自己创建的向量作为数据源</span></span><br><span class="line">p &lt;- p + geom_line(colour=<span class="string">&quot;red&quot;</span>, linetype=<span class="number">2</span>) <span class="comment"># 画上一条曲线</span></span><br><span class="line">p &lt;- p + geom_point(colour=<span class="string">&quot;blue&quot;</span>, shape=<span class="number">0</span>) <span class="comment"># 把点也画上</span></span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820105700.png" style="zoom:50%;" /><h3 id="坐标轴和图表的标题：xlab-，ylab-和ggtitle">坐标轴和图表的标题：<code>xlab()</code>，<code>ylab()</code>和<code>ggtitle()</code></h3><p>这三个就没啥好理解的啦，<code>xlab()</code>和<code>ylab()</code>明显就是设定x和y轴的标题（不写这两个函数的话就默认像上面一样显示x和y），<code>ggtitle()</code>也很显然就是设定图表的标题。这三个默认都不支持中文哈，如果需要显示中文的话可以找我帮你解决（可能和python的matplotlib一样需要修改字体文件）。运行一下试试：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- p + xlab(<span class="string">&quot;hahahahaha&quot;</span>) + ylab(<span class="string">&quot;hehehehehe&quot;</span>) + ggtitle(<span class="string">&quot;lalalalala&quot;</span>)</span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820110358.png" style="zoom:50%;" /><h3 id="设定图片尺寸：使用options-函数">设定图片尺寸：使用<code>options()</code>函数</h3><p>图画的实在是太小了怎么办？可以使用<code>options(repr.plot.width=8, repr.plot.height=6)</code>来解决。这句话的意思就是把宽度和高度设为某个值，这个值你可以自定义。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">options(repr.plot.width=<span class="number">8</span>, repr.plot.height=<span class="number">6</span>)</span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><p>效果如下：</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820110838.png" style="zoom:50%;" /><h2 id="使用NASA行星数据画基本散点图">使用NASA行星数据画基本散点图</h2><h3 id="绘制轨道周期和轨道偏心率关系的散点图">绘制轨道周期和轨道偏心率关系的散点图</h3><p>在本节中，我们将使用数据库中的两个关键参数来创建2D图形：pl_orbopriod（轨道周期period）和pl_orbeccen（轨道偏心率eccentricity）。轨道周期定义了行星完成绕恒星轨道所花费的时间；轨道偏心率是介于0和1之间的数字，它确定行星轨道是完美的圆形（0）还是椭圆形（1）。</p><h4 id="数据预处理——分组、按需取出子集">数据预处理——分组、按需取出子集</h4><p>首先，由于我们想比较用不同方法发现的系外行星的属性，因此我们可以使用之前学习过的分组统计方法，对所有行星的数据按照“pl_discmethod”列也就是“发现方式”对数据进行分组和频率的统计。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照“pl_discmethod”列对数据进行分组并生成频率统计表</span></span><br><span class="line">kdf_new &lt;- kdf %&gt;%</span><br><span class="line">    group_by(pl_discmethod) %&gt;%</span><br><span class="line">    summarise(n = n())</span><br><span class="line"></span><br><span class="line">print(kdf_new)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820112141.png" style="zoom:50%;" /><p>假设我们想要把Transit、Radial Velocity、Imaging三种“发现方式”的行星放到一个表里去作图，我们可以用两种方法制作这样一个数据集。第一种是使用<code>filter()</code>先按照发现方式分别把这三种过滤到三个表中，再通过一个叫做<code>rbind()</code>的函数把这三个表堆叠起来，就合并成了一个表。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分别过滤出三个发现方式的所有数据</span></span><br><span class="line">T_group &lt;- kdf %&gt;%</span><br><span class="line">    filter(pl_discmethod == <span class="string">&quot;Transit&quot;</span>)</span><br><span class="line">RV_group &lt;- kdf %&gt;%</span><br><span class="line">    filter(pl_discmethod == <span class="string">&quot;Radial Velocity&quot;</span>)</span><br><span class="line">I_group&lt;- kdf %&gt;%</span><br><span class="line">    filter(pl_discmethod == <span class="string">&quot;Imaging&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆叠并打印</span></span><br><span class="line">plot.df &lt;- rbind(T_group, RV_group, I_group)</span><br><span class="line">print(plot.df)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820123529.png" style="zoom:50%;" /><p>第二种方式是在过滤器中直接使用“或”，也就是<code>|</code>符号，来取三个条件的并集。（显然这种更推荐）</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plot.df &lt;- kdf %&gt;%</span><br><span class="line">    filter(pl_discmethod == <span class="string">&quot;Transit&quot;</span> | pl_discmethod == <span class="string">&quot;Radial Velocity&quot;</span> | pl_discmethod == <span class="string">&quot;Imaging&quot;</span>)</span><br><span class="line">print(plot.df)</span><br></pre></td></tr></table></figure><p>这两行代码的输出和上面的基本是一样的，如果看上去不太一样，那是因为堆叠是一种一种叠起来，而多条件筛选显然是在原表中一行一行筛选的，顺序会不太一样，总归没什么区别就是了。</p><h4 id="按照取出的数据集画散点图">按照取出的数据集画散点图</h4><p>我们来厘清一下要求：绘制散点图，横轴是轨道周期，纵轴是轨道偏心率，用颜色区分不同的“发现方式”——这个功能可以在生成画布的时候使用<code>colour = pl_discmethod</code>参数来实现。ggplot2中，如果我们想让颜色colour或者尺寸size这种样式的差别来区分不同类别，需要在<code>ggplot()</code>的参数<code>aes()</code>中补充形如aes(x, y, size=…, colour=…)这种形式的参数。而如果我们只是想设定画线或者画点的尺寸，则是在<code>geom_line()</code>或者<code>geom_point()</code>函数中指定<code>colour=..., size=...</code>等，同时使用<code>scale_colour_discrete(name='name')</code>或者<code>scale_size=(name=name)</code>来绘制图例和图例的title。这一点要记得区分一下。</p><p>首先输入xy轴参数和颜色参数生成画布，然后再加入绘制散点的函数<code>geom_point()</code>，似乎就大功告成了。我们来写一下代码：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 pl_discmethod 这一列数据来区分颜色</span></span><br><span class="line">p &lt;- ggplot(plot.df, aes(pl_orbper,pl_orbeccen, colour = pl_discmethod)) + geom_point()</span><br><span class="line"><span class="comment"># 加上两个坐标轴的标题</span></span><br><span class="line">p &lt;- p + xlab(<span class="string">&quot;Period (Days)&quot;</span>) + ylab(<span class="string">&quot;Eccentricity&quot;</span>)</span><br><span class="line"><span class="comment"># 图片搞大一点方便看</span></span><br><span class="line">options(repr.plot.width=<span class="number">9</span>, repr.plot.height=<span class="number">6</span>)</span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820125621.png" style="zoom:50%;" /><p>啊这……点怎么都挤在一起了，右边空空荡荡，左边几乎变成一条实线，这能看出来个啥？所以我们不能就此罢休，还是要继续搞一下。</p><p>我们发现，问题主要是出在因为x轴的尺度上。y轴的数据只在0-1的区间上变化，而轨道周期除了极个别的大数值以外，也在较小的数字区间上密集分布。这种不均匀分布我们称之为倾斜分布/偏斜分布。这时候如果我们能把刻度转为非线性的形式，就能够清晰地展示更多数据。</p><p>我们尝试在绘图过程中增加<code>scale_x_log10()</code>把x轴尺度转换成以10为底的对数刻度来绘制这个散点图（对应的如果数据在y轴上倾斜分布可以用<code>scale_y_log10()</code>）。同时，我也希望能够使用<code>scale_colour_discrete(name = &quot;Discovery Method&quot;)</code>给图例命名成“Discovery Method”，毕竟“pl_discmethod”很少有人能理解是什么意思。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和上面一样的代码</span></span><br><span class="line">p &lt;- ggplot(plot.df, aes(pl_orbper,pl_orbeccen, colour = pl_discmethod)) + geom_point()</span><br><span class="line">p &lt;- p + xlab(<span class="string">&quot;Period (Days)&quot;</span>) + ylab(<span class="string">&quot;Eccentricity&quot;</span>)</span><br><span class="line">p  &lt;- p + ggtitle(<span class="string">&quot;Figure 1: Discovery methods&quot;</span>)</span><br><span class="line"><span class="comment"># x轴转换为非线性的对数尺度，同时给区分颜色的图例加上标题</span></span><br><span class="line">p &lt;- p + scale_x_log10() + scale_colour_discrete(name = <span class="string">&quot;Discovery Method&quot;</span>)</span><br><span class="line"><span class="comment"># 图搞大点</span></span><br><span class="line">options(repr.plot.width=<span class="number">9</span>, repr.plot.height=<span class="number">6</span>)</span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820140626.png" style="zoom:50%;" /><p>这样效果就很棒棒了。</p><p>“这张图显示了有关我们太阳系的一些有趣信息。 尽管我们系统中的所有行星都具有相似的低偏心率，但系外行星的偏心率范围更广，从0到0.8。 同样，低偏心率的行星的周期很短，这表明它们离恒星非常近，这是我们在太阳系中没有观察到的，这使我们成为稀有且独特的行星系。”</p><h3 id="绘制恒星质量和轨道周期关系的散点图">绘制恒星质量和轨道周期关系的散点图</h3><p>下面要求绘制<strong>x轴和y轴均使用对数尺度</strong>的恒星质量（st_mass）与行星轨道周期（pl_orbper）的函数关系，我们试试给数据点指定size为10且颜色为蓝色，看看效果是否很怪异。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据点指定size为10且颜色为蓝色，注意不需要区分类的情况下，样式参数是写在aes外面的</span></span><br><span class="line">p &lt;- ggplot(kdf, aes(pl_orbper,st_mass)) + geom_point(size=<span class="number">10</span>,colour=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置x和y两个坐标轴标题</span></span><br><span class="line">p  &lt;- p + xlab(<span class="string">&#x27;Planet Orbital Period (days)&#x27;</span>) + ylab(<span class="string">&#x27;Stellar Mass (Solar mass)&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置图片标题</span></span><br><span class="line">p &lt;- p + ggtitle(<span class="string">&#x27;Figure 2: Log-Log Plot&#x27;</span>)</span><br><span class="line"><span class="comment"># 转换坐标轴尺度，x轴和y轴均使用对数尺度</span></span><br><span class="line">p &lt;- p + scale_x_log10() + scale_y_log10()</span><br><span class="line"><span class="comment"># 画大一点</span></span><br><span class="line">options(repr.plot.width=<span class="number">7</span>, repr.plot.height=<span class="number">7</span>)</span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820142100.png" style="zoom:50%;" /><h2 id="绘制更复杂的散点图">绘制更复杂的散点图</h2><p>接下来这段代码可能看起来很唬人，但是分解开来理解还是比较直观的。</p><p>我们的目的是使用颜色区分“行星平衡温度”的差别，希望散点的颜色不再是简单的红绿蓝，而是可以在一个色带中平滑过度，就好像用红外线成像仪拍出来的热力图一样，颜色越冷代表温度越低，颜色越暖代表温度越高，颜色总体在红和蓝之间过渡。</p><p>但是我们会遇到一些阻力。首先是平滑过渡的“jet colours”在R语言中并没有定义出来，我们需要单独使用一个向量、利用<code>colorRampPalette()</code>调色盘函数创建一个平滑过渡的jet色带。代码如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己去定义色谱范围：蓝色、靛青、亮黄、红色作为四个基准点过渡的平滑色带</span></span><br><span class="line">jet.colors &lt;-</span><br><span class="line">  colorRampPalette(c(<span class="string">&quot;#00007F&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;#007FFF&quot;</span>, <span class="string">&quot;cyan&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;#7FFF7F&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;#FF7F00&quot;</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;#7F0000&quot;</span>))</span><br></pre></td></tr></table></figure><p>第二个是在原始数据表中，有些星球由于尚未探测，所以温度标注为“NA”。这对于画图的函数来说是一个困扰，因为无法给它分配颜色。我们希望能够简单地将NA的数据改写为1，保证图像顺利生成。<code>is.na(table[&quot;col&quot;])</code>可以返回一个向量，这个向量包含了tablename表内col这一列的值为NA的所有行号。我们使用这个行号和col作为下标，把所有NA改为1。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># is.na(kdf[&#x27;pl_eqt&#x27;])输出kdf表内pl_eqt这一列为NA的所有行序号的向量，把这些行的pl_eqt改为1</span></span><br><span class="line">kdf[is.na(kdf[<span class="string">&#x27;pl_eqt&#x27;</span>]),<span class="string">&#x27;pl_eqt&#x27;</span>] &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后一个问题就是，前面创建的色带怎么设置为我们画图的颜色？还记得上面有一个给图例命名的函数，我们只需要在这个函数里加一个<code>colours=jet.colors(10)</code>就可以调用我们的色带，其中10的意思是我们使用这个色带中的10个色阶，也就是只用这个色带中的10个“断点”作为我们绘图的颜色。</p><p>了解了这些，我们来看看完整的代码。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己去定义色谱范围：蓝色、靛青、亮黄、红色作为四个基准点过渡的平滑色带</span></span><br><span class="line">jet.colors &lt;-</span><br><span class="line">  colorRampPalette(c(<span class="string">&quot;#00007F&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;#007FFF&quot;</span>, <span class="string">&quot;cyan&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;#7FFF7F&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;#FF7F00&quot;</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;#7F0000&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># is.na(kdf[&#x27;pl_eqt&#x27;])输出kdf表内pl_eqt这一列为NA的所有行序号的向量，把这些行的pl_eqt改为1</span></span><br><span class="line">kdf[is.na(kdf[<span class="string">&#x27;pl_eqt&#x27;</span>]),<span class="string">&#x27;pl_eqt&#x27;</span>] &lt;- <span class="number">1</span></span><br><span class="line"><span class="comment"># 创建画布，pl_orbper作为横轴，st_mass作为纵轴，使用颜色编码数据+绘制散点</span></span><br><span class="line">p &lt;- ggplot(kdf, aes(pl_orbper,st_mass,colour=pl_eqt)) + geom_point()</span><br><span class="line"><span class="comment"># 创建色带图例和标题</span></span><br><span class="line">p &lt;- p + scale_colour_gradientn(name=<span class="string">&#x27;Planet Equilibrium Temperature (K)&#x27;</span>,</span><br><span class="line">                              colours=jet.colors(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标记坐标轴和图表标题</span></span><br><span class="line">p &lt;- p + xlab(<span class="string">&#x27;Planet Orbital Period (days)&#x27;</span>) + ylab(<span class="string">&#x27;Solar Mass (Solar mass)&#x27;</span>) + ggtitle(<span class="string">&#x27;Figure 3: Colour-Coded scatter plot&#x27;</span>)</span><br><span class="line"><span class="comment"># 两个坐标轴都用log10尺度</span></span><br><span class="line">p &lt;- p + scale_x_log10() + scale_y_log10()</span><br><span class="line"><span class="comment"># 设定一下画布尺寸</span></span><br><span class="line">options(repr.plot.width=<span class="number">7</span>, repr.plot.height=<span class="number">5</span>)</span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820144213.png" style="zoom:67%;" /><p>结果非常的amazing啊！温度分布一目了然，处于左上角的明显温度偏高。@Keren Wang 请问这个你用excel能画嘛？三个维度，平滑过渡，画死你。</p><p>当然你也可以试着用size来反应温度的差别：温度越高点越大。这部分试着自己理解一下权当复习了，反正我也是自己试出来的（用你老师的话说：多试几遍run several more goes），直接放代码：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># is.na(kdf[&#x27;pl_eqt&#x27;])输出kdf表内pl_eqt这一列为NA的所有行序号的向量，把这些行的pl_eqt改为1</span></span><br><span class="line">kdf[is.na(kdf[<span class="string">&#x27;pl_eqt&#x27;</span>]),<span class="string">&#x27;pl_eqt&#x27;</span>] &lt;- <span class="number">1</span></span><br><span class="line"><span class="comment"># 创建画布，pl_orbper作为横轴，st_mass作为纵轴，使用“尺寸/10” 编码数据+绘制散点</span></span><br><span class="line">p &lt;- ggplot(kdf, aes(pl_orbper,st_mass,size=pl_eqt/<span class="number">10</span>)) + geom_point()</span><br><span class="line"><span class="comment"># 创建尺寸图例和标题</span></span><br><span class="line">p &lt;- p + scale_size(name=<span class="string">&#x27;Planet Equilibrium Temperature (K)&#x27;</span>)</span><br><span class="line"><span class="comment"># 标记坐标轴和图表标题</span></span><br><span class="line">p &lt;- p + xlab(<span class="string">&#x27;Planet Orbital Period (days)&#x27;</span>) + ylab(<span class="string">&#x27;Solar Mass (Solar mass)&#x27;</span>) + ggtitle(<span class="string">&#x27;Figure 3: Colour-Coded scatter plot&#x27;</span>)</span><br><span class="line"><span class="comment"># 两个坐标轴都用log10尺度</span></span><br><span class="line">p &lt;- p + scale_x_log10() + scale_y_log10()</span><br><span class="line"><span class="comment"># 设定一下画布尺寸</span></span><br><span class="line">options(repr.plot.width=<span class="number">7</span>, repr.plot.height=<span class="number">5</span>)</span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820145041.png" style="zoom: 67%;" /><p>或者在彩色图的基础上直接改：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己去定义色谱范围：蓝色、靛青、亮黄、红色作为四个基准点过渡的平滑色带</span></span><br><span class="line">jet.colors &lt;-</span><br><span class="line">  colorRampPalette(c(<span class="string">&quot;#00007F&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;#007FFF&quot;</span>, <span class="string">&quot;cyan&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;#7FFF7F&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;#FF7F00&quot;</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;#7F0000&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># is.na(kdf[&#x27;pl_eqt&#x27;])输出kdf表内pl_eqt这一列为NA的所有行序号的向量，把这些行的pl_eqt改为1</span></span><br><span class="line">kdf[is.na(kdf[<span class="string">&#x27;pl_eqt&#x27;</span>]),<span class="string">&#x27;pl_eqt&#x27;</span>] &lt;- <span class="number">1</span></span><br><span class="line"><span class="comment"># 创建画布，pl_orbper作为横轴，st_mass作为纵轴，使用颜色编码数据+绘制散点</span></span><br><span class="line">p &lt;- ggplot(kdf, aes(pl_orbper,st_mass,colour=pl_eqt,size=pl_eqt/<span class="number">10</span>)) + geom_point()</span><br><span class="line"><span class="comment"># 创建图例和标题</span></span><br><span class="line">p &lt;- p + scale_colour_gradientn(name=<span class="string">&#x27;Planet Equilibrium Temperature (K)&#x27;</span>,</span><br><span class="line">                              colours=jet.colors(<span class="number">10</span>))</span><br><span class="line">p &lt;- p + scale_size_continuous(name=<span class="string">&#x27;Planet Equilibrium Temperature (K)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标记坐标轴和图表标题</span></span><br><span class="line">p &lt;- p + xlab(<span class="string">&#x27;Planet Orbital Period (days)&#x27;</span>) + ylab(<span class="string">&#x27;Solar Mass (Solar mass)&#x27;</span>) + ggtitle(<span class="string">&#x27;Figure 3: Colour-Coded scatter plot&#x27;</span>)</span><br><span class="line"><span class="comment"># 两个坐标轴都用log10尺度</span></span><br><span class="line">p &lt;- p + scale_x_log10() + scale_y_log10()</span><br><span class="line"><span class="comment"># 设定一下画布尺寸</span></span><br><span class="line">options(repr.plot.width=<span class="number">7</span>, repr.plot.height=<span class="number">5</span>)</span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820145630.png" style="zoom:67%;" /><p>这几种呈现方式都是非常综合且直观的。小贴士：如果你不想要某个图例，那就把guide设置成None就好了，比如上面这个例子里我们想把size的示例去掉，只用改一句：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820150037.png" alt=""></p><p>看看是不是你不想要的图例已经没有了？</p><h2 id="使用geom-histogram-函数绘制直方图">使用<code>geom_histogram()</code>函数绘制直方图</h2><p>我们的数据表中有一列pl_disc记录了这个行星被发现的年份。如果我们想知道每年有多少行星被发现，也就是一个年份为横坐标的频度图，那么直方图会是一个比较合适的选择。<code>geom_histogram(binwidth=2, fill=&quot;red&quot;)</code>表示绘制宽度为2、填充色为红色的直方图。还是依照原来的老样子，我们绘制<code>aes(pl_disc)</code>的画布（如果aes只有一个参数，那么它会去统计这个参数的频率分布），然后在上面增加直方图。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建画布并添加宽度为2、填充色为红色的直方图</span></span><br><span class="line">p &lt;- ggplot(kdf,aes(pl_disc)) + geom_histogram(binwidth=<span class="number">2</span>, fill=<span class="string">&quot;red&quot;</span>)</span><br><span class="line"><span class="comment"># 添加xy轴标题和图表标题</span></span><br><span class="line">p &lt;- p + xlab(<span class="string">&quot;Years&quot;</span>) + ylab(<span class="string">&quot;Number of exoplanets&quot;</span>)</span><br><span class="line">p &lt;- p + ggtitle(<span class="string">&quot;Histogram of number of discovered exoplanets&quot;</span>)</span><br><span class="line"><span class="comment"># 指定画布尺寸</span></span><br><span class="line">options(repr.plot.width=<span class="number">8</span>, repr.plot.height=<span class="number">6</span>)</span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200820150802.png" style="zoom:67%;" /><p>曲线、散点、直方图，这就是使用R语言绘图的三个最基础的内容，更多的方法可以在书中、网上探索。</p><p><a href="https://davekim3872.github.io/2020/08/23/text-mining-twitter/">下一篇：R语言-分析与绘图（4）：对twitter数据进行文本挖掘</a></p>]]></content>
      
      
      <categories>
          
          <category> R语言数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> Tidyverse </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-分析与绘图（2）：使用rvest库抓取和分析网页信息</title>
      <link href="/2020/08/15/webpages-analyze/"/>
      <url>/2020/08/15/webpages-analyze/</url>
      
        <content type="html"><![CDATA[<p>上一篇：<a href="https://davekim3872.github.io/2020/08/14/R-tidyverse-one/">R语言-分析与绘图（1）：使用tidyverse工具包处理数据</a></p><p>并不是所有网站都会提供可下载的数据文件，因此在某些场景下需要我们使用rvest工具包去爬取网页上展示出来的数据并整理成R或者说tidyverse可以处理的数据格式。可以理解成实现简单的爬虫。</p><h2 id="rvest工具包">rvest工具包</h2><p><a href="https://www.rdocumentation.org/packages/rvest/versions/0.3.6">官方文档</a>对于rvest的介绍非常简洁：</p><ul><li><em>rvest帮助你从网页中抓取信息。它被设计成与magrittr一起工作，使其更容易表达常见的web抓取任务，灵感来自于像beautiful soup这样的库。</em></li></ul><p>虽然没听说过magrittr这个东西，但是beautiful soup我是听说过的。所以在我的理解下，rvest大抵就是一种html解析器。它独立于上一次的tidyverse，所以需要单独安装（也需要安装其依赖的xml2）然后导入：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">install.packages(c(<span class="string">&quot;rvest&quot;</span>, <span class="string">&quot;xml2&quot;</span>))</span><br><span class="line"><span class="keyword">library</span>(tidyverse)</span><br><span class="line"><span class="keyword">library</span>(rvest)</span><br></pre></td></tr></table></figure><p>网站的页面一般使用html（超文本标记语言）书写，为了浏览器能成功解析并展示内容，html的各个版本有着非常<s>乱七八糟</s>规范统一的格式要求，不同的内容在代码中使用标签进行分块。这种特性为各种工具解析html提供了非常大的便利。</p><p>为了抓取网页文件及其中某些区域（如页面上显示的表格）的信息，除了复制粘贴、手动输入这种非常低效的办法，我们也可以选择使用rvest等工具定位到html的固定代码块并按照规则进行解析。</p><h2 id="爬取网页文件及其中的表格">爬取网页文件及其中的表格</h2><p>我们以<a href="https://en.wikipedia.org/wiki/List_of_Academy_Award-winning_films">维基百科-奥斯卡学院奖</a>条目为例，尝试获取历年获奖电影的表格。该表格在网页上显示如下：</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815163837.png" style="zoom: 50%;" /><p>为了完成这个目标，我们需要用到rvest的三个比较关键的方法：<code>read_html()</code>，<code>html_nodes()</code>和<code>html_table()</code>。</p><h3 id="read-html"><code>read_html()</code></h3><p><code>read_html()</code>的作用是把页面源代码html文件读取成一个列表，这个列表中存储着页面中不同的对象。我们使用以下示例代码爬取上述网页html中的对象列表。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 页面url</span></span><br><span class="line">url &lt;- <span class="string">&quot;https://en.wikipedia.org/wiki/List_of_Academy_Award-winning_films&quot;</span></span><br><span class="line"><span class="comment"># 读取页面源码</span></span><br><span class="line">wikipage &lt;- read_html(url)</span><br><span class="line"><span class="comment"># 用字符串形式展示读取内容的格式</span></span><br><span class="line">str(wikipage)</span><br></pre></td></tr></table></figure><p>需要注意的是，访问维基百科需要使用代理以绕开GFW，请自行百度“在终端中使用代理的方法”或者在代理软件中直接设置系统代理+全局模式。否则，终端或者jupyter会报错：</p><ul><li>Error in open.connection(x, “rb”): LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to <a href="http://en.wikipedia.org:443">en.wikipedia.org:443</a>.</li></ul><p>备用的解决方案是下载<a href="https://wwa.lanzous.com/i1VSUfnhvde">我上传的压缩包</a>并把其中的所有文件放到代码相同目录下，里面有本文需要的所有html文件；然后将上文的第二行代码修改为：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地页面源码（相对）路径</span></span><br><span class="line">url &lt;- <span class="string">&quot;Award.html&quot;</span></span><br><span class="line"><span class="comment"># 读取页面源码</span></span><br><span class="line">wikipage &lt;- read_html(url)</span><br><span class="line"><span class="comment"># 用字符串形式展示读取内容的格式</span></span><br><span class="line">str(wikipage)</span><br></pre></td></tr></table></figure><p>如果成功读取，输出的字符串应该是这样子：</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815165446.png" style="zoom: 50%;" /><h3 id="html-nodes"><code>html_nodes()</code></h3><p>上文说过，<code>read_html()</code>的作用是把页面源代码html文件读取成一个列表。这个列表中存储的其实是不同的源代码块所表示的对象。这个网页上可能有多个“table”对象，而我们只需要爬取页面上的第一个表格。因此，需要再次解析上文存储的对象列表<code>wikipage</code>，从中搜索关键字为“table”的对象列表，并取出列表当中的第一个对象。</p><p><code>html_nodes()</code>函数的作用是在<code>read_html()</code>读出来的对象列表中通过关键字取出我们需要的对象的列表（比如我们需要找出所有“table”关键字的对象），而我们可以在这样的一个列表中通过下标取出其中的一个DataFrame对象（比如按照我们上文的需求取出第一个）。示例代码如下。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取出对象列表中关键字为“table”的第一个对象</span></span><br><span class="line">movies_alt &lt;- html_nodes(wikipage, <span class="string">&quot;table&quot;</span>)[[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>需要注意的是，在R语言中对于list对象而言，单层的中括号形如<code>object[1]</code>并不是其他语言当中按照下标索引取对象的意思，而是指向自己本身。如果我们需要按照下标索引取list中的对象，必须使用双层中括号形如<code>object[[1]]</code>（尽管匪夷所思，但是语法和规则本就是应该无条件遵守的东西，否则大家口味喜好不同，全世界可能每个人都在讲不同的语言了）。</p><h3 id="html-table"><code>html_table()</code></h3><p>在上一步，我们使用<code>html_nodes(wikipage, &quot;table&quot;)[[1]]</code>读出来的<code>movies_alt</code>是啥？是个对象。但我们做数据分析需要的是DataFrame，所以<code>html_table()</code>函数就是用来把DataFrame的对象转为真正的DataFrame格式。如下所示执行函数，并使用<code>head()</code>展示一下我们历经千辛万苦扒出来的表格。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把对象转为真正的DataFrame格式</span></span><br><span class="line">movies &lt;- html_table(movies_alt)</span><br><span class="line"><span class="comment"># 展示表格前几行</span></span><br><span class="line">head(movies)</span><br></pre></td></tr></table></figure><p>当然，如果想避免使用那么多中间变量倒来倒去，也可以使用之前学过的管道<code>%&gt;%</code>进行一段前后连贯的操作。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取出对象列表中关键字为“table”的第一个对象</span></span><br><span class="line">movies &lt;- html_nodes(wikipage, <span class="string">&quot;table&quot;</span>)[[<span class="number">1</span>]] %&gt;%</span><br><span class="line">  <span class="comment"># 把对象转为真正的DataFrame格式</span></span><br><span class="line">  html_table()</span><br><span class="line"><span class="comment"># 展示表格前几行</span></span><br><span class="line">head(movies)</span><br></pre></td></tr></table></figure><p>这两段代码的输出相同，长这个样子：</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815174156.png" style="zoom:50%;" /><h2 id="整理读取出来的表格">整理读取出来的表格</h2><p>细心的你可能已经发现了，上面读出来的表格有一些小问题：Year，Awards，Nominations三列都是<code>&lt;chr&gt;</code>格式。数据分析的基础是数值型数据，因此我们需要把这几列数字转换为数值格式的数据。之前学过类型转换函数<code>as_numeric()</code>和修改表格列的函数<code>mutate()</code>，这时候就起作用了：我们只需要把对应的列修改成这一列类型转换后的结果即可。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用管道的写法（推荐用这个！）</span></span><br><span class="line">movies &lt;- movies %&gt;%</span><br><span class="line">    mutate(Awards = as.numeric(Awards))</span><br><span class="line">head(movies)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 不使用管道的写法（不太好）</span></span><br><span class="line">movies &lt;- mutate(movies, Awards = as.numeric(Awards))</span><br><span class="line">head(movies)</span><br></pre></td></tr></table></figure><p>除了使用mutate函数之外，使用<code>$</code>美元符号也可以直接指定DataFrame中的数据列并进行修改（新知识哦）：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新方法：$符号直接把某一列拿出来改</span></span><br><span class="line">movies$Awards &lt;- as.numeric(movies$Awards)</span><br><span class="line">head(movies)</span><br></pre></td></tr></table></figure><p>输出长这样：</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815182421.png" style="zoom:50%;" /><p>哈，上面报了一个Warning，字面意思是有的列的值无法转为数值，可能因为它根本不是一个数字。我们看到的这几行里好像没有出现这种情况，但是既然报了警告就说明确实存在这样的数据。这样的数据会被表示为<code>NA</code>，也就是Not Available的意思。为了展示一下，可以尝试输出2017年的最后几行数据：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用filter筛选一下2017年的数据</span></span><br><span class="line">mov_2017 = filter(movies, Year == <span class="number">2017</span>)</span><br><span class="line">tail(mov_2017)</span><br></pre></td></tr></table></figure><p>看看输出，你就知道上面为啥报错了。2017年的电影Flesh and Sand的Awards这一列是一个无法转换为数值的变量。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815183830.png" style="zoom:50%;" /><p>回去看一下网页上这一行长什么样子：</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815183925.png" style="zoom: 50%;" /><p>Fine，好像确实不是一个规范的数字，又带括号又带下标的。我们大可以一通操作手动修改这个数据为0或者1，像下面这样：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到这个电影的索引</span></span><br><span class="line">idx &lt;- summarize(movies, which(Film == <span class="string">&quot;Flesh and Sand (Carne y arena)&quot;</span>))</span><br><span class="line"><span class="comment"># 索引转为数值，把这一行的Awards修改为1</span></span><br><span class="line">movies$Awards[[as.numeric(idx)]] &lt;- <span class="number">1</span></span><br><span class="line"><span class="comment"># 重新筛选一下2017年的电影</span></span><br><span class="line">mov_2017 = filter(movies, Year == <span class="number">2017</span>)</span><br><span class="line"><span class="comment"># 看一下尾部几行</span></span><br><span class="line">tail(mov_2017)</span><br></pre></td></tr></table></figure><p>结果是ok的，但是那样的操作既费事又没有意义，所以我们干脆用一种叫做<code>na.omit()</code>的方法把所有有NA数值的行都去掉。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table &lt;- na.omit(mov_2017)</span><br><span class="line">tail(table)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815185729.png" style="zoom:50%;" /><p>最后让我们来尝试使用管道把上面这些代码封装一下，不要用那么多的中间变量倒来倒去。尝试一行一行理解这些代码，尝试对照着写一遍，并且尝试自己独立写一遍。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movies &lt;- html_nodes(wikipage, <span class="string">&quot;table&quot;</span>)[[<span class="number">1</span>]]  %&gt;%</span><br><span class="line">    html_table() %&gt;%</span><br><span class="line">    mutate(Awards = as.numeric(Awards),</span><br><span class="line">           Nominations = as.numeric(Nominations)) %&gt;%</span><br><span class="line">    na.omit()</span><br><span class="line">    </span><br><span class="line">head(movies)</span><br></pre></td></tr></table></figure><h3 id="变通地使用之前学过的方法">变通地使用之前学过的方法</h3><p>还记不记得之前学过的<a href="https://davekim3872.github.io/2020/08/14/R-tidyverse-one/#%E6%9C%80%E5%A4%A7-%E6%9C%80%E5%B0%8F%E5%80%BC%E8%AE%A1%E7%AE%97">summarize方法</a>？<code>summarize()</code>函数的<strong>输出是一个DataFrame</strong>，这一点要切记。里可以引用函数<code>which.max()</code>和<code>which.min()</code>，当时我们还不会<code>$</code>直接引用DataFrame里的列。今天我们学了这个方法后，这两个方法可以作为返回整数的函数使用了——也就是说，输入一列，返回一个整数。比如下面这行运行的结果直接就是输出47.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which.max(movies$Nominations)</span><br></pre></td></tr></table></figure><p>再结合我们之前学的<a href="https://davekim3872.github.io/2020/08/14/R-tidyverse-one/#%E9%80%89%E5%8F%96%E6%9F%90%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%EF%BC%88%E8%A1%8C%E4%B8%8E%E5%88%97%E7%9A%84%E7%BB%84%E5%90%88%EF%BC%89">操作DataFrame</a>（或者DataFrame的高级版——tibble，二者差别不大）的方法，我们可以用<code>表[行, 列]</code>的方式输出我们需要的信息啦。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出movies表里Nominations这一列值最大的这一行的所有列（记得留逗号）</span></span><br><span class="line">movies[which.max(movies$Nominations),]</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815191637.png" style="zoom: 50%;" /><p>当然也可以用<code>filter()</code>筛选我们想要的子集，在这里只写管道的写法了，以后都尽量用管道来完成多步操作，这样会比较符合人类思考的逻辑（拿来一个东西，对它先进行某操作，再进行某操作）。我们试试在原始数据集中筛选2018年的子集。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movies2018 &lt;- movies %&gt;%</span><br><span class="line">    <span class="comment"># 先把年份转换为数值</span></span><br><span class="line">    mutate(Year = as.numeric(Year)) %&gt;%</span><br><span class="line">    <span class="comment"># 再过滤一下，留2018年的</span></span><br><span class="line">    filter(Year == <span class="number">2018</span>)</span><br><span class="line"></span><br><span class="line">head(movies2018)</span><br></pre></td></tr></table></figure><h2 id="爬取更复杂的表格">爬取更复杂的表格</h2><p>这个表格只提供了本地的html源码，先老样子读取表格。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置本地html路径</span></span><br><span class="line">url=<span class="string">&quot;MovieBudgets.html&quot;</span></span><br><span class="line"><span class="comment"># 读取html文件</span></span><br><span class="line">m_numbers &lt;-  read_html(url)</span><br><span class="line"><span class="comment"># 把第一个表格关键字的对象转为DataFrame</span></span><br><span class="line">table &lt;- html_nodes(m_numbers,<span class="string">&quot;table&quot;</span>)[[<span class="number">1</span>]] %&gt;%</span><br><span class="line">      <span class="comment"># 下面这句里加了fill参数为TRUE，意思是自动用NA填充不完整的行</span></span><br><span class="line">         html_table(fill=<span class="literal">TRUE</span>)</span><br><span class="line">head(table)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815193624.png" style="zoom:50%;" /><p>看看爬出来的表格结构是啥。可以用之前的<code>summary(table)</code>，也可以用<code>str(table)</code>用字符串形式展示结构。后者输出结果长这样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815193101.png" alt=""></p><p>不管你用了哪种方法，应该都能看到第一列数值是没有名字的。我们可以用<code>names()</code>或者<code>colnames()</code>函数为第一列分配一个名字“Name”。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># option 1</span></span><br><span class="line">names(table)[<span class="number">1</span>] &lt;- <span class="string">&quot;Number&quot;</span></span><br><span class="line"><span class="comment"># option 2</span></span><br><span class="line">colnames(table)[<span class="number">1</span>] &lt;- <span class="string">&quot;Number&quot;</span></span><br><span class="line">head(table)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815193732.png" style="zoom:50%;" /><h3 id="在字符串中搜索数字">在字符串中搜索数字</h3><p>接下来的任务是想办法把那几列美元单位的字符串转换为数值。tidyverse也贴心地提供了一个<code>parse_number()</code>方法，可以对它输入一个字符串，它能帮你找出这段字符串里第一段数字（比如输入@#abc1234$%^def5678ghi，会输出1234）。这刚好能满足我们的需求。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为这个管道输入table</span></span><br><span class="line">table_1 &lt;- table %&gt;%</span><br><span class="line">    <span class="comment"># 修改表格：DomesticGross和ProductionBudget两列转为数字</span></span><br><span class="line">    mutate(DomesticGross = parse_number(DomesticGross),</span><br><span class="line">           ProductionBudget = parse_number(ProductionBudget))</span><br><span class="line">head(table_1)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815194623.png" style="zoom:50%;" /><p>再重申一下，为啥一定要转为数字呢，因为我们要做数据的分析运算啥的，字符串做不了这个。比如我想求一下电影票房收入和国内总收入的比率，这时候才可以计算：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在最后插一列呗</span></span><br><span class="line">table_1 &lt;- mutate(table_1, <span class="string">&quot;DomesticRatio&quot;</span> = ProductionBudget / DomesticGross)</span><br><span class="line">head(table_1)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815195433.png" style="zoom:50%;" /><h2 id="创建一个频率表（frequency-table）">创建一个频率表（frequency table）</h2><p><code>n()</code>是计算频率的函数，使用形如<code>group_by(xxx) %&gt;% summarize(freq = n())</code>的管道函数可以很快捷地生成一列名为freq的xxx频率的表。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地html路径</span></span><br><span class="line">url=<span class="string">&quot;BigFiveAcademyAwardwinners.html&quot;</span></span><br><span class="line"><span class="comment"># 读取html</span></span><br><span class="line">m_numbers &lt;-  read_html(url)</span><br><span class="line"><span class="comment"># 转换为Data Frame数据表（这次我们需要的表是第二个）</span></span><br><span class="line">Table &lt;- html_nodes(m_numbers,<span class="string">&quot;table&quot;</span>)[[<span class="number">2</span>]] %&gt;%</span><br><span class="line">         html_table(fill=<span class="literal">TRUE</span>) </span><br><span class="line">head(Table)</span><br><span class="line"><span class="comment"># 对Table按照Best Actress进行分组，建立频率表</span></span><br><span class="line">BestActress_df &lt;- Table %&gt;%</span><br><span class="line">   group_by(`Best Actress`) %&gt;%</span><br><span class="line">   mutate(summarise(n = n())</span><br><span class="line"></span><br><span class="line">head(BestActress_df)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815203725.png" style="zoom:50%;" /><h3 id="按照某一列进行升-降序排序">按照某一列进行升/降序排序</h3><p>终于来到了“我用excel一下就做出来了”的环节，问题是excel没法爬网页上的table啊 🐶</p><p>使用<code>arrange()</code>函数可以快捷地对按照某一列进行排序。这个地方注意有个坑：<code>group_by()</code>函数里面填写的列名前后要加重音记号 `  （键盘左上角那个符号），我们在下面代码中尝试按照上面计算的频率进行升序排序。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BestActress_df &lt;- Table %&gt;%</span><br><span class="line">    <span class="comment"># 记得加``</span></span><br><span class="line">    group_by(`Best Actress`) %&gt;%</span><br><span class="line">    <span class="comment"># 插入一列频率</span></span><br><span class="line">    mutate(Freq = n()) %&gt;%</span><br><span class="line">    <span class="comment"># 按照频率进行升序排序，降序排序是arrange(desc(Freq))</span></span><br><span class="line">    arrange(Freq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这次改成看屁股</span></span><br><span class="line">tail(BestActress_df)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815210408.png" style="zoom:50%;" /><p>最后一列可以看出来，是升序排序了。</p><h2 id="画个图吧？">画个图吧？</h2><p>上一篇里好像提了一嘴ggplot2，这是出自tidyverse作者之手的绘图工具包。我们先不展开讲，先欣赏一下代码和结果（我会写一点简单的注释，但是这个工具在后面的notes中会展开聊一下）</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一行是使用reorder函数对原来的表依照Freq进行重新排序，确定x、y轴的含义</span></span><br><span class="line">ggplot(BestActress,aes(x = reorder(`Best Actress`, Freq), y=Freq)) + </span><br><span class="line">        <span class="comment"># 设置外观参数</span></span><br><span class="line">        geom_bar(stat=<span class="string">&#x27;identity&#x27;</span>,fill=<span class="string">&#x27;darkgreen&#x27;</span>) +</span><br><span class="line">        <span class="comment"># 坐标轴上的文字标记</span></span><br><span class="line">        coord_flip() +</span><br><span class="line">        labs(x = <span class="string">&quot;Best Actress&quot;</span>, y = <span class="string">&quot;Nominations&quot;</span>)</span><br><span class="line"></span><br><span class="line">ggsave(<span class="string">&#x27;result.pdf&#x27;</span>)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200815212041.png" style="zoom: 33%;" /><p>我觉得比Excel画的图显得Professional！</p><p>下一篇：<a href="https://davekim3872.github.io/2020/08/20/data-visulization-intro/">R语言-分析与绘图（3）：可视化入门</a></p>]]></content>
      
      
      <categories>
          
          <category> R语言数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Rvest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言-分析与绘图（1）：使用tidyverse工具包处理数据</title>
      <link href="/2020/08/14/R-tidyverse-one/"/>
      <url>/2020/08/14/R-tidyverse-one/</url>
      
        <content type="html"><![CDATA[<p>上一篇：<a href="https://davekim3872.github.io/2020/08/12/jupyter-notebook-R/">在MacOS上安装以及使用Jupyter Notebook运行R语言</a></p><p>给媳妇@Keren Wang整理的一点学习笔记。希望可以帮你把这部分内容掌握透彻。</p><h2 id="tidyverse和鹦鹉书">tidyverse和鹦鹉书</h2><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/R-datascience.png" style="zoom:50%;" /><p>悉尼大学*OLET1601 Analysing and Plotting Data: R (Online)*的学习路线是先从tidyverse这个工具包开始。关于这个工具包，网上的中文资料几乎没有，但是细心的同学会发现OREILLY经典的《R for Data Science》猫头鹰鹦鹉书就是围绕着tidyverse展开的。事实上，这本书的作者、RStudio首席科学家Hadley Wickham就是tidyverse和ggplot2的作者。所以其实除了<a href="https://www.tidyverse.org/packages/">官方的英文文档</a>以外，中英文版本的猫头鹰鹦鹉书也是非常理想的参考资料。<a href="https://r4ds.had.co.nz/">英文版本</a>的可以在线阅读，<a href="https://wwa.lanzous.com/i2LJffm0kxa">中文版本</a>的我上传了一版pdf，有需要的自取，如有侵权请联系本人删除。</p><p>如果是在本地环境而非在线练习网站上运行tidyverse相关代码，我们需要在R语言中安装这个工具包：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">&quot;tidyverse&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="需要重申的基本概念">需要重申的基本概念</h2><p>（这一段主要写给第一节课没有好好复盘的@Keren Wang。）</p><ul><li><p><strong>返回值（return）</strong>：可以理解为一个函数执行后的输出。</p></li><li><p><strong>赋值语句</strong>：将某个值（数值、数据结构）赋给某个变量的过程。简单来说，以下语句都是典型的赋值语句。</p></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- <span class="number">1</span></span><br><span class="line">b = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">c = c(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">d &lt;- paste(a, b, c, <span class="string">&#x27;yes&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​在执行完赋值表达式后，赋值符号（<code>&lt;-</code>或者<code>=</code>）左边的变量就被赋予了代表右边的值（数值、数据结构、表达式执行结果）的含义。</p><ul><li><p><strong>向量（Vector）</strong>：向量从数据结构上看就是一个线性表（列表），可以看成一个数组。R 语言中向量作为一种类型存在可以让向量的操作变得更加容易。</p></li><li><p><strong><code>c()</code></strong> ：是一个创造向量的函数。我们新建两个向量<code>a, b</code>并输出向量加法的结果作为示例。</p></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = c(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">b = c(<span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">a + b</span><br></pre></td></tr></table></figure><p>​运行代码，得到下图的结果，即输出<code>[3, 4] + [5, 0]</code>的运算结果：向量<code>[8, 4]</code></p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200814130610.png" style="zoom: 67%;" /><ul><li><p><strong>加或者不加<code>print()</code>的区别</strong>：在上图所示的例子中，我们可以看到即使没有<code>print(a + b)</code>也输出了结果。如果加上，那输出是这样：</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200814132503.png" style="zoom:67%;" /><p>看起来好像只是多了个行序号而已。那么加不加<code>print()</code>有什么区别呢？事实上，只有在终端、jupyter等工作空间中逐行运行程序的时候，直接把某个值作为语句执行才会输出结果；而在运行一段脚本文件（xxx.R）的时候，没有使用<code>print()</code>函数的值语句是无法打印出来的。</p></li><li><p><strong>拼接字符串</strong>：R语言中使用<code>paste()</code>函数对字符串进行拼接，该函数接收数个值作为参数，拼接时会自动在值之间添加空格，返回值为一个字符串。</p></li></ul><h2 id="载入包、读取和展示数据">载入包、读取和展示数据</h2><h3 id="载入tidyverse">载入tidyverse</h3><p>我们使用下列两条语句之一载入tidyverse工具包：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># option 1:</span></span><br><span class="line"><span class="keyword">library</span>(tidyverse)</span><br><span class="line"><span class="comment"># option 2:</span></span><br><span class="line"><span class="keyword">require</span>(tidyverse)</span><br></pre></td></tr></table></figure><p>在R语言中，<code>library()</code>和<code>require()</code>都可以载入工具包，二者之间的区别是后者具有<code>bool</code>类型的返回值：在一个函数中，如果一个包不存在，执行到<code>library()</code>将会停止执行，<code>require()</code>则会返回<code>false</code>后继续执行。下图就是获取了<code>require(tidyverse)</code>的返回值并输出结果，可以看到，因为载入了正确的包，<code>require()</code>输出了<code>true</code>。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/2020-08-14%20at%201.35%20PM.png"  /><p>而如果载入了不存在或者未安装的包，则会返回<code>false</code>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/2020-08-14%20at%201.38%20PM.png" alt=""></p><h3 id="读取数据">读取数据</h3><p>使用<code>read_delim()</code>可以读取任意分隔符的文件。在本章我们只需要了解该函数的两个参数即可：<code>read_delim(&quot;文件名&quot;, delim = &quot;分隔符类型&quot;)</code>。下面两行代码分别代表读取使用逗号分隔的&quot;OECDpop.csv&quot;文件和读取使用空格分隔的“AustraliaDemographics.dat”文件（<a href="https://wwa.lanzous.com/if67Ufm7l5a">点击下载上述文件</a>），返回一个<code>tibble()</code>类型的数据表（dataframe），并赋给名为<code>pop_data</code>的变量。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取使用逗号分隔的&quot;OECDpop.csv&quot;文件</span></span><br><span class="line">pop_data = read_delim(<span class="string">&#x27;OECDpop.csv&#x27;</span>,delim = <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="comment"># 读取使用空格分隔的“AustraliaDemographics.dat”文件</span></span><br><span class="line">pop_data &lt;- read_delim(<span class="string">&quot;AustraliaDemographics.dat&quot;</span>, delim = <span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="展示数据">展示数据</h3><ul><li>对于tibble类型的数据表，<code>tail()</code>和<code>head()</code>函数分别可以返回数据表的最后和最前6行。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回最后6行</span></span><br><span class="line">tail(pop_data)</span><br><span class="line"><span class="comment"># 返回最前6行</span></span><br><span class="line">head(pop_data)</span><br></pre></td></tr></table></figure><ul><li>对于tibble类型的数据表，<code>summary()</code>函数可以输出数据表每一列的名称、数据类型、数值型数据的各种统计值和非数值型数据的长度。</li></ul><h3 id="选取某一部分数据（行与列的组合）">选取某一部分数据（行与列的组合）</h3><ul><li>假如我想在pop_data这个表中选取“Total”这一列，可以使用类似数组下标的方式。同时，如果下标有两项，第一项代表的就是行号。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取出Total这一列</span></span><br><span class="line">a &lt;- pop_data[<span class="string">&quot;Total&quot;</span>]</span><br><span class="line"><span class="comment"># 取出Total这一列的第五行</span></span><br><span class="line">b &lt;- pop_data[<span class="number">5</span>, <span class="string">&quot;Total&quot;</span>]</span><br></pre></td></tr></table></figure><ul><li>如果我想选择某几列的数据，需要先把这几列的标题建立成一个向量，然后再对这个向量取下标。同时，如果下标有两项，第一项代表的是行号，且行号也可以是一个向量（代表取不止一行）</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取出这三列</span></span><br><span class="line">a &lt;- pop_data[c(<span class="string">&quot;Male&quot;</span>, <span class="string">&quot;Female&quot;</span>, <span class="string">&quot;Total&quot;</span>)]</span><br><span class="line"><span class="comment"># 取出这三列的第五行</span></span><br><span class="line">b &lt;- pop_data[<span class="number">5</span>, c(<span class="string">&quot;Male&quot;</span>, <span class="string">&quot;Female&quot;</span>, <span class="string">&quot;Total&quot;</span>)]</span><br><span class="line"><span class="comment"># 取出这三列的第5、6、7行</span></span><br><span class="line">c &lt;- pop_data[c(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>), c(<span class="string">&quot;Male&quot;</span>, <span class="string">&quot;Female&quot;</span>, <span class="string">&quot;Total&quot;</span>)]</span><br><span class="line"><span class="comment"># 取出Total这一列的第5、6、7行</span></span><br><span class="line">d &lt;- pop_data[c(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>), <span class="string">&quot;Total&quot;</span>]</span><br></pre></td></tr></table></figure><ul><li>总而言之，就是单个值和向量的<strong>自由组合</strong>。但是注意⚠️：即使想取所有列，把列标题留空，也必须在行号后面保留逗号。如下所示：</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取出所有列的第5、6、7行的错误做法</span></span><br><span class="line">a &lt;- pop_data[c(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)]</span><br><span class="line"><span class="comment"># 取出所有列的第5、6、7行的正确做法</span></span><br><span class="line">a &lt;- pop_data[c(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>), ]</span><br></pre></td></tr></table></figure><h2 id="使用tidyverse简单分析数据">使用tidyverse简单分析数据</h2><h3 id="最大-最小值计算">最大/最小值计算</h3><p>假如我想计算某一列的最大值或者最小值，可以使用<code>summarize()</code>函数。该函数接收两个参数：<code>summarize(数据表名, which.max(列标题)或者which.min(列标题))</code>，输出的是tibble DataFrame格式当中的一个单元格，需要通过下文的强制类型转换为正常的数值才能进行运算。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算pop_data表中Female这一列的最大值</span></span><br><span class="line">idx &lt;- summarize(pop_data, which.max(Female))</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p><code>summarize()</code>函数是一种通过某些计算输出新的DataFrame的函数，它接收DataFrame和需要生成的内容的规则作为参数，输出一个DataFrame格式的数据（可以是行号数据或者是一列数据）。</p></li><li><p>后面我们会了解到，<code>summarize()</code>函数中的参数如果是which/which.xxx函数的话，输出的就是某一行的index；而如果是条件表达式<code>xx == &quot;xxx&quot;</code>的话，输出的就是一列完整的数据。下一章中我们会使用这个特性建立频率表。</p></li></ul><h3 id="类型转换">类型转换</h3><p>在数据表中即使精确定位了某一行、某一列的数据，输出的数据类型也仍然是tibble类型，如上文的<code>idx</code>变量。为了对这些数据进行运算或者操作，tidyverse定义了强制类型转换函数如<code>as.numeric()</code>和<code>as.character()</code>：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将idx转为数字后作为行标，取出这一行的State这一列，即得到了女性最多的州</span></span><br><span class="line">fem_max_state &lt;- pop_data[as.numeric(idx),<span class="string">&quot;State&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="管道（pipeline）">管道（pipeline）</h3><p>管道是一种组合多个操作的方式。简单来说，如果你想对a进行b操作后计算得到c值，你大可以一步步保存中间变量，再做下一步操作；但是也可以通过管道的方式，使用<code>%&gt;%</code>连接前后操作。我们以<em>对pop_data按照State分组后，使用一个<code>summarize</code>函数分别计算出每个State的男性人口最大值、平均值和标准差，并保存到一个叫做sum的数据表当中</em>为例，介绍管道的用法。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义保存结果的变量名sum</span></span><br><span class="line">sum &lt;- pop_data %&gt;%</span><br><span class="line">      <span class="comment"># 使用group_by进行分组后</span></span><br><span class="line">      group_by(`State`) %&gt;%</span><br><span class="line">      <span class="comment"># 对每一组进行summarize</span></span><br><span class="line">      summarize(</span><br><span class="line">          <span class="comment"># 计算男性人口最大值</span></span><br><span class="line">          max_M = max(Male),</span><br><span class="line">          <span class="comment"># 计算男性人口平均值</span></span><br><span class="line">          average_M = mean(Male),</span><br><span class="line">          <span class="comment"># 计算男性人口标准差</span></span><br><span class="line">          st_dev_M = sd(Male)</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>运行sum输出一下，表格长这样：</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200814145444.png" style="zoom:67%;" /><h3 id="增加或修改列">增加或修改列</h3><p>使用<code>mutate()</code>函数增加或者修改列，函数必须接收数据表的名称和使用数据表中某些列进行的运算操作作为参数。<code>mutate()</code>总是将新列添加在数据集的最后。举例来说，使用管道新建列计算女性百分比的操作是这样写的：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果不想覆盖原来的数据表，可以新建变量写成 new_pop_data &lt;- pop_data %&gt;%</span></span><br><span class="line">pop_data &lt;- pop_data %&gt;%</span><br><span class="line">    mutate(women_perc = Female/Total*<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>如果不想使用管道，也可以写成：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop_data &lt;- mutate(</span><br><span class="line">  <span class="comment"># 如果不想覆盖原来的数据表，可以新建变量写成 new_pop_data,</span></span><br><span class="line">  pop_data,</span><br><span class="line">  women_perc = Female/Total*<span class="number">100</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>运行<code>head(pop_data)</code>输出一下，两种方法都输出了这个：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200814150631.png" alt=""></p><p>可以看到，我们新建的women_perc已经添加在了最后。</p><h3 id="过滤（filter）">过滤（filter）</h3><p><code>filter()</code>是tidyverse非常重要的一种方法。一般来说，这个函数接受的第一个参数是数据表的名称，后面数个参数是我们需要设定的过滤器，格式为“属性 == 某个值”。理解起来非常直白，下面展示几个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取出子集：NSW州的人口数据表</span></span><br><span class="line">df_nsw_T &lt;- filter(pop_data, State == <span class="string">&quot;NSW&quot;</span>)</span><br><span class="line"><span class="comment"># 取出子集：ACT州的人口数据表中的Male这一列</span></span><br><span class="line">df_act_male &lt;- filter(pop_data, State == <span class="string">&quot;NSW&quot;</span>)[<span class="string">&quot;Male&quot;</span>]</span><br><span class="line"><span class="comment"># 取出子集：VIC州的人口数据表中2014年数据的的Male和Female这两列</span></span><br><span class="line">df_vic_14_mf &lt;- filter(pop_data, State == <span class="string">&quot;VIC&quot;</span>, Year == <span class="number">2014</span>)[c(<span class="string">&quot;Male&quot;</span>, <span class="string">&quot;Female&quot;</span>)]</span><br></pre></td></tr></table></figure><h3 id="保留小数">保留小数</h3><p>使用<code>round()</code>函数控制保留位数（四舍五入）。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对浮点数3.1415926取小数点后3位，输出：3.142</span></span><br><span class="line">pie &lt;- round(<span class="number">3.1415926</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p>[1] Tidyverse Official Homepage <a href="https://www.tidyverse.org/packages/">https://www.tidyverse.org/packages/</a></p><p>[2] R for Data Science <a href="https://r4ds.had.co.nz/">https://r4ds.had.co.nz/</a></p><p>下一篇：<a href="https://davekim3872.github.io/2020/08/15/webpages-analyze/">R语言-分析与绘图（2）：使用rvest库抓取和分析网页信息</a></p>]]></content>
      
      
      <categories>
          
          <category> R语言数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> Dataframe </tag>
            
            <tag> Tidyverse </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1.两数之和 &amp; 15.三数之和</title>
      <link href="/2020/08/13/leetcode-two-sum-three-sum/"/>
      <url>/2020/08/13/leetcode-two-sum-three-sum/</url>
      
        <content type="html"><![CDATA[<h3 id="两数之和（Two-Sum）——梦开始的地方">两数之和（Two Sum）——梦开始的地方</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></p><p>这就是单词表里的Abandon Abort一类的存在，helfront world新手体验局，没啥好说的，我也没啥新颖的解法，遍历元素然后<code>HashMap</code>查表匹配<code>target - nums[i]</code>就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(target - nums[i]);</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三数之和（Three-Sum）">三数之和（Three Sum）</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></p><p>题目是说需要把给出的list里相加为0的三元组找出来。一开始除了根本ac不了的暴力解法想不到什么思路，就大概参考一下热度比较高的思路。</p><h4 id="双指针法">双指针法</h4><p>双指针法的原理是在<strong>已排序</strong>的数组内使用一头一尾两个指针向中间移动以找到两数之和等于指定值的全部组合。（所以啊，这也可以解决第一个问题）本题为三数之和，可以在排序的数组中先固定一个数（从前向后遍历），将这个数字的相反数作为target，实现以这个数字之后的list为范围的双指针两数之和问题。具体来说也就是两个步骤：</p><ol><li>排序。这个可以不用费时间了（之后应该会再总结一遍各种排序算法，虽然已经被大家讲烂了，但对于我来说好记性不如烂笔头），直接调库<code>Arrays.sort(num)</code>就好了。给自己多啰嗦一句，<code>Array</code>的排序底层实现是混合的，对于<code>length() &lt; 47</code>的列表直接使用插入排序，大于这个长度的使用<a href="https://www.cnbfrontgs.com/nullzx/p/5880191.html">双轴快排</a>。</li><li>遍历数组和双指针算法。需要注意的是，我们操作三个元素，分别为遍历的时候固定的元素、双指针的头指针元素和尾指针元素，对于这三个元素而言在其移动方向上如果有前后重复都应该排除掉，否则就有可能出现重复的三元组。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length-<span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; num[i] == num[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> front = i+<span class="number">1</span>, rear = num.length-<span class="number">1</span>, sum = <span class="number">0</span> - num[i];</span><br><span class="line">            <span class="keyword">while</span> (front &lt; rear) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[front] + num[rear] == sum) &#123;</span><br><span class="line">                    res.add(Arrays.asList(num[i], num[front], num[rear]));</span><br><span class="line">                    <span class="keyword">while</span> (front &lt; rear &amp;&amp; num[front] == num[front+<span class="number">1</span>])&#123;</span><br><span class="line">                    front++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (front &lt; rear &amp;&amp; num[rear] == num[rear-<span class="number">1</span>]) &#123;</span><br><span class="line">                      rear--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    front++;</span><br><span class="line">                  rear--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num[front] + num[rear] &lt; sum) front++;</span><br><span class="line">                <span class="keyword">else</span> rear--;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外好像还有更优的解法，一刷暂时先不管那么多，先把通用方法记牢了再说吧。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> medium difficulty </tag>
            
            <tag> easy difficulty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在MacOS上安装以及使用Jupyter Notebook运行R语言</title>
      <link href="/2020/08/12/jupyter-notebook-R/"/>
      <url>/2020/08/12/jupyter-notebook-R/</url>
      
        <content type="html"><![CDATA[<p>本指南适用于MacOS 10.13及以上的系统。不确定有没有用的环境依赖是xcode commandline tools，不嫌麻烦可以提前装一下，很多东西都要用到这个。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install </span><br></pre></td></tr></table></figure><h3 id="走流程介绍一下R">走流程介绍一下R</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/200px-R_logo.svg.png" alt=""></p><p>R语言，一种自由软件编程语言与操作环境，主要用于统计分析、绘图、数据挖掘。R本来是由来自新西兰奥克兰大学的罗斯·伊哈卡和罗伯特·杰特曼开发（也因此称为R），现在由“R开发核心团队”负责开发。R基于S语言的一个GNU计划项目，所以也可以当作S语言的一种实现，通常用S语言编写的代码都可以不作修改的在R环境下运行。R的语法是来自Scheme。</p><p>R的源代码可自由下载使用，亦有已编译的可执行文件版本可以下载，可在多种平台下运行，包括UNIX（也包括FreeBSD和Linux）、Windows和MacOS。R主要是以命令行操作，同时有人开发了几种图形用户界面，其中RStudio是最为广泛使用的集成开发环境。</p><h2 id="环境配置过程">环境配置过程</h2><h3 id="安装Anaconda">安装Anaconda</h3><p>如果已经安装过了（打开终端试试<code>conda --version</code>命令），就直接看下一部分。</p><p>按照我的习惯，一般是用脚本安装。Anaconda官网的<a href="https://www.anaconda.com/products/individual#macos">下载页面</a>直接拉到底，下载命令行安装文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/2020-08-12%20at%207.28%20PM.png" alt=""></p><p>终端进入下载文件夹，输入<code>bash Anaconda3-2020.07-MacOSX-x86_64.sh</code>（具体版本看你下载文件的名字），一路下一步，遇到y/n就选y。安装完成后重启终端，应该长这样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/2020-08-12%20at%207.37%20PM.png" alt=""></p><p>如果想在新建环境里执行下面的操作，可以输入以下命令新建并激活环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n env_name python=3 ipython jupyterlab</span><br><span class="line">conda activate env_name</span><br></pre></td></tr></table></figure><p>我在这里不讲如何新建环境了，所有操作直接在base环境里执行。在进行下一步操作前，可以尝试输入<code>jupyter notebook</code>或者<code>jupyter lab</code>看一下服务有没有正常启动。</p><h3 id="安装R语言组件">安装R语言组件</h3><p>我们以（当时）最新的R-4.0.2版本为例。R官网贴心为各国商科精英们准备了物理距离尽可能短的镜像。下表是中国境内的服务器：</p><table><thead><tr><th>R-4.0.2.pkg 下载链接</th><th>镜像源</th></tr></thead><tbody><tr><td><a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg">https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg</a></td><td>TUNA Team, Tsinghua University</td></tr><tr><td><a href="https://mirrors.bfsu.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg">https://mirrors.bfsu.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg</a></td><td>Beijing Foreign Studies University</td></tr><tr><td><a href="https://mirrors.ustc.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg">https://mirrors.ustc.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg</a></td><td>University of Science and Technology of China</td></tr><tr><td><a href="https://mirror-hk.koddos.net/CRAN/bin/macosx/R-4.0.2.pkg">https://mirror-hk.koddos.net/CRAN/bin/macosx/R-4.0.2.pkg</a></td><td>KoDDoS in Hong Kong</td></tr><tr><td><a href="https://mirrors.e-ducation.cn/CRAN/bin/macosx/R-4.0.2.pkg">https://mirrors.e-ducation.cn/CRAN/bin/macosx/R-4.0.2.pkg</a></td><td>Elite Education</td></tr><tr><td><a href="https://mirror.lzu.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg">https://mirror.lzu.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg</a></td><td>Lanzhou University Open Source Society</td></tr><tr><td><a href="https://mirrors.nju.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg">https://mirrors.nju.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg</a></td><td>eScience Center, Nanjing University</td></tr><tr><td><a href="https://mirrors.tongji.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg">https://mirrors.tongji.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg</a></td><td>Tongji University</td></tr><tr><td><a href="https://mirrors.sjtug.sjtu.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg">https://mirrors.sjtug.sjtu.edu.cn/CRAN/bin/macosx/R-4.0.2.pkg</a></td><td>Jiao Tong University</td></tr></tbody></table><p><strong>安装“R-4.0.2.pkg”前务必注意！⚠️⚠️⚠️：</strong></p><p>在<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/macosx">下载链接</a>页面有一段小字：</p><p>​<em>Note: the use of X11 (including <code>tcltk</code>) requires <a href="http://xquartz.macosforge.org/">XQuartz</a> to be installed since it is no longer part of OS X. Always re-install XQuartz when upgrading your macOS to a new major version.</em></p><p>一定要注意，这时候先按照要求把<a href="http://xquartz.macosforge.org/">XQuartz</a>装上，不然之后会出状况（后文简述现象）。</p><p>正常运行pkg文件，一路下一步，安装。Launchpad出现R.app的图标。当然我们一般用不着这个东西。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200812192304.png" alt=""></p><p>终端输入R并回车，应该长这样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/2020-08-12%20at%207.53%20PM.png" alt=""></p><p>这样R语言相关组件就算安装好了，实在不放心也可以试试hello world：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/2020-08-12%20at%207.54%20PM.png" alt=""></p><h3 id="安装IRkernel">安装IRkernel</h3><p>和python在jupyter上解释需要依赖iPython、iPykernel同理，R语言脚本在jupyter上运行也依赖于一种即时的解释器内核iRkernel。和pip或者conda类似，我们也需要使用R的包管理工具先安装依赖环境。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(c(<span class="string">&#x27;repr&#x27;</span>, <span class="string">&#x27;IRdisplay&#x27;</span>, <span class="string">&#x27;evaluate&#x27;</span>, <span class="string">&#x27;crayon&#x27;</span>, <span class="string">&#x27;pbdZMQ&#x27;</span>, <span class="string">&#x27;devtools&#x27;</span>, <span class="string">&#x27;uuid&#x27;</span>, <span class="string">&#x27;digest&#x27;</span>))</span><br></pre></td></tr></table></figure><p>执行第一句脚本的时候会让选镜像仓库，这时候就可以看出问题的端倪了：如果像我一样没有安装<a href="http://xquartz.macosforge.org/">XQuartz</a>，就不会弹出一个类似GUI的东西让你选择仓库，而是直接命令行输入序号。如果是这样，可以先不用装这些了，先回去把XQuartz装好吧。否则就会报告如下错误：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Error <span class="keyword">in</span> (<span class="keyword">function</span> (display = <span class="string">&quot;&quot;</span>, width, height, pointsize, gamma, <span class="built_in">bg</span>,  : </span><br><span class="line">  X11 module cannot be loaded</span><br><span class="line">In addition: Warning message:</span><br><span class="line">In (<span class="keyword">function</span> (display = <span class="string">&quot;&quot;</span>, width, height, pointsize, gamma, <span class="built_in">bg</span>,  :</span><br><span class="line">  unable to load shared object <span class="string">&#x27;/Library/Frameworks/R.framework/Resources/modules//R_X11.so&#x27;</span>:</span><br><span class="line">  dlopen(/Library/Frameworks/R.framework/Resources/modules//R_X11.so, 6): Library not loaded: /usr/X11/lib/libSM.6.dylib</span><br><span class="line">  Referenced from: /Library/Frameworks/R.framework/Resources/modules//R_X11.so</span><br><span class="line">  Reason: image not found</span><br></pre></td></tr></table></figure><p>这是因为MacOS在更新10.13版本的时候替换掉了原有的X11 module。而如果按照我之前说的先安装了XQuartz，则应该有类似这样的一个选择界面：</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200812173144.png" style="zoom: 33%;" /><p>好了，接下来就是选择合适的仓库，然后一路安装，出现如下结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200812180446.png" alt=""></p><p>再执行：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devtools::install_github(<span class="string">&#x27;IRkernel/IRkernel&#x27;</span>)</span><br><span class="line">IRkernel::installspec()</span><br></pre></td></tr></table></figure><p>终端界面应该长这样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200812180618.png" alt=""></p><p>退出R终端，新建一个终端输入jupyter notebook，看看右上角有没有新建R语言notebook的选项了？</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200812180648.png" style="zoom:50%;" /><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DaveKim3872/blogpics/20200812180749.png" alt=""></p><p>这就算完事啦～</p><p>（如果还是有问题，不妨试试完全卸载后重装。⚠️注意：卸载需要按照这个教程——<a href="https://blog.csdn.net/jackliu91/article/details/45772775">《OS X下卸载R语言》</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> Anaconda </tag>
            
            <tag> Jupyter Notebook </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 384.打乱数组</title>
      <link href="/2020/08/12/Leetcode-384-shuffle-list/"/>
      <url>/2020/08/12/Leetcode-384-shuffle-list/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/shuffle-an-array/">384. 打乱数组 - 力扣（LeetCode）</a></p><p>先从一道没什么技术含量的题开始了。本题引入了Fisher Yates洗牌算法原理，其实质是相同概率下的元素选取和交换：从后向前（或从前向后）遍历数组，将当前遍历到的元素与其前面（后面）的任意数字交换后固定不变。取随机数的过程调用了java的Random类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java解法——从后向前</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ori;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        <span class="keyword">this</span>.ori = nums.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Resets the array to its original configuration and return it. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ori;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns a random shuffling of the array. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = random.nextInt(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int[] param_1 = obj.reset();</span></span><br><span class="line"><span class="comment"> * int[] param_2 = obj.shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>python的话，import random也可以达到相同效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffle</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.output)):</span><br><span class="line">        j = random.randint(i, len(self.output) - <span class="number">1</span>)</span><br><span class="line">        self.output[i], self.output[j] = self.output[j], self.output[i]</span><br><span class="line">    <span class="keyword">return</span> self.output</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> medium difficulty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终于（重新）把Blog收拾了出来</title>
      <link href="/2020/08/10/first-post/"/>
      <url>/2020/08/10/first-post/</url>
      
        <content type="html"><![CDATA[<p>大概是去年的这个时候，也是用hexo和butterfly，搞了一个blog。纯粹为了新奇，没有任何motivation，因为那时候要上课要学习又想抓紧一切贪玩的时间，更没有意识到自己还有太多太多需要学习和积累的东西。成绩嘛，够申请够毕业就差不多；又不急着找工作，刷什么题记什么笔记。</p><p>教训是，我必须永远意识到：</p><ol><li>人外有人，天外有天——此刻看到的优秀的人不及明日会遇到的优秀的人的能力和数量的十分之一</li><li>物质世界不以人的意志为转移——人太渺小了，一旦意外袭来，毫无反抗之力</li></ol><p>所以也就不甘心地拿着心仪的offer被困在了围城里动弹不得。以为能够提升能力的机会快要失之交臂，自己却又抓不到面前最好的机会，实在是苍白。</p><p>不知不觉入职已经一个多月了，上周开始学新的内容、扩展业务面和技术栈，突然意识到自己需要积累一点东西了，不是给任何人看，而是踏踏实实用键盘把自己不善于书写的内容码下来，内容包括但不仅限于刷力扣、学新的开发工具、复习语言的基础用法、学习新的业务领域、半年后（希望可以）记一下上课笔记。反正，微软不倒闭，我的笔记就还在，虽然没去北极，但应该也不至于一定要撑到穿越虫洞移居外星系的那一天。</p><p>除此之外，关于自己喜欢的事物、生活的感触，也会抽时间稍微啰嗦一下，平时没人听没人管，大脑里的垃圾也总算是找到一个合适的去处。</p><p>好了，差不多简单说一下，然后我要去赶班车了。</p><p>Btw，今天下了好大的雨，不是我喜欢的天气。</p>]]></content>
      
      
      <categories>
          
          <category> 乱七八糟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
